Web Development with
Node and Express

Ethan Brown


Web Development with Node and Express

by Ethan Brown

Copyright © 2014 Ethan Brown1 All rights reserved1
Printed in the United States of America1

Published by O1Reilly Media, Inc1, 1005 Gravenstein Highway North, Sebastopol, 
CA 954721

O1Reilly books may be purchased for educational, business, or sales promotional 
use1 Online editions are
also available for most titles (http://my1safaribooksonline1com)1 For more 
information, contact our corporate/
institutional sales department: 800-998-9938 or corporate@oreilly1com1


Editors: Simon St1 Laurent and Brian Anderson

Production Editor: Matthew Hacker
Copyeditor: Linley Dolby
Proofreader:    Rachel Monaghan

July 2014:                  First Edition

Revision History for the First Edition:

2014-06-27:    First release

Indexer: Ellen Troutman Zaig
Cover Designer: Karen Montgomery
Interior Designer: David Futato
Illustrator: Rebecca Demarest

See http://oreilly1com/catalog/errata1csp?isbn=9781491949306 for release 
details1

Nutshell Handbook, the Nutshell Handbook logo, and the O1Reilly logo are 
registered trademarks of O1Reilly
Media, Inc1 Web Development with Node and Express, the picture of a black lark 
and a white-winged lark,
and related trade dress are trademarks of O1Reilly Media, Inc1

Many of the designations used by manufacturers and sellers to distinguish their 
products are claimed as
trademarks1 Where those designations appear in this book, and O1Reilly Media, 
Inc1 was aware of a trademark
claim, the designations have been printed in caps or initial caps1

While every precaution has been taken in the preparation of this book, the 
publisher and author assume no
responsibility for errors or omissions, or for damages resulting from the use 
of the information contained
herein1

ISBN: 978-1-491-94930-6
[LSI]


This book is dedicated to my family:

My father, Tom, who gave me a love of engineering; my mother, Ann, who gave me 
a love
of writing; and my sister, Meris, who has been a constant companion1



Table of Contents

Foreword1                                                                       
                                           xiii

Preface1                                                                        
                                              xv

11  Introducing Express1                                                        
                                        1

The JavaScript Revolution                                                       
                              1

Introducing Express                                                             
                                 2

A Brief History of Express                                                      
                              4

Upgrading to Express 410                                                        
                              4

Node: A New Kind of Web Server                                                  
                       5

The Node Ecosystem                                                              
                              6

Licensing                                                                       
                                       7

21  Getting Started with Node1                                                  
                                     9

Getting Node                                                                    
                                    9

Using the Terminal                                                              
                                10

Editors                                                                         
                                       11

npm                                                                             
                                       12

A Simple Web Server with Node                                                   
                      13

Hello World                                                                     
                                14

Event-Driven Programming                                                        
                    14

Routing                                                                         
                                  15

Serving Static Resources                                                        
                           15

Onward to Express                                                               
                               17

31  Saving Time with Express1                                                   
                                    19

Scaffolding                                                                     
                                     19

The Meadowlark Travel Website                                                   
                      20

Initial Steps                                                                   
                                      20

Views and Layouts                                                               
                            24


Static Files and Views                                                          
                             26

Dynamic Content in Views                                                        
                      27

Conclusion                                                                      
                                28

41  Tidying Up1                                                                 
                                           29

Best Practices                                                                  
                                    29

Version Control                                                                 
                                 30

How to Use Git with This Book                                                   
                        30

If You1re Following Along by Doing It Yourself                                  
               31

If You1re Following Along by Using the Official Repository                      
        32

npm Packages                                                                    
                                 33

Project Metadata                                                                
                                 34

Node Modules                                                                    
                                34

51  Quality Assurance1                                                          
                                       37

QA: Is It Worth It?                                                             
                                  38

Logic Versus Presentation                                                       
                            39

The Types of Tests                                                              
                                 39

Overview of QA Techniques                                                       
                         40

Running Your Server                                                             
                              40

Page Testing                                                                    
                                    41

Cross-Page Testing                                                              
                                44

Logic Testing                                                                   
                                    47

Linting                                                                         
                                       48

Link Checking                                                                   
                                 49

Automating with Grunt                                                           
                           49

Continuous Integration (CI)                                                     
                          52

61  The Request and Response Objects1                                           
                              53

The Parts of a URL                                                              
                                53

HTTP Request Methods                                                            
                          54

Request Headers                                                                 
                                55

Response Headers                                                                
                               55

Internet Media Types                                                            
                              56

Request Body                                                                    
                                  56

Parameters                                                                      
                                    57

The Request Object                                                              
                               57

The Response Object                                                             
                             59

Getting More Information                                                        
                          60

Boiling It Down                                                                 
                                 61

Rendering Content                                                               
                           61

Processing Forms                                                                
                             63


Providing an API                                                                
                             64

71  Templating with Handlebars1                                                 
                                 67

There Are No Absolute Rules Except This One                                     
              68

Choosing a Template Engine                                                      
                         69

Jade: A Different Approach                                                      
                           69

Handlebars Basics                                                               
                                71

Comments                                                                        
                               72

Blocks                                                                          
                                    72

Server-Side Templates                                                           
                           74

Views and Layouts                                                               
                            74

Using Layouts (or Not) in Express                                               
                     76

Partials                                                                        
                                    77

Sections                                                                        
                                   79

Perfecting Your Templates                                                       
                         80

Client-Side Handlebars                                                          
                          81

Conclusion                                                                      
                                   83

81  Form Handling1                                                              
                                        85

Sending Client Data to the Server                                               
                         85

HTML Forms                                                                      
                                85

Encoding                                                                        
                                    86

Different Approaches to Form Handling                                           
                  87

Form Handling with Express                                                      
                         89

Handling AJAX Forms                                                             
                           90

File Uploads                                                                    
                                    92

jQuery File Upload                                                              
                                94

91  Cookies and Sessions1                                                       
                                      99

Externalizing Credentials                                                       
                           100

Cookies in Express                                                              
                              101

Examining Cookies                                                               
                            103

Sessions                                                                        
                                    103

Memory Stores                                                                   
                           103

Using Sessions                                                                  
                             104

Using Sessions to Implement Flash Messages                                      
              105

What to Use Sessions For                                                        
                          106

101  Middleware1                                                                
                                        109

Common Middleware                                                               
                        114


Third-Party Middleware                                                          
                         116

111  Sending Email1                                                             
                                        117

SMTP, MSAs, and MTAs                                                            
                       117

Receiving Email                                                                 
                               118

Email Headers                                                                   
                                118

Email Formats                                                                   
                                119

HTML Email                                                                      
                               119

Nodemailer                                                                      
                                 120

Sending Mail                                                                    
                              120

Sending Mail to Multiple Recipients                                             
                  121

Better Options for Bulk Email                                                   
                        122

Sending HTML Email                                                              
                         122

Images in HTML Email                                                            
                     123

Using Views to Send HTML Email                                                  
               123

Encapsulating Email Functionality                                               
                  125

Email as a Site Monitoring Tool                                                 
                        127

121  Production Concerns1                                                       
                                     129

Execution Environments                                                          
                         129

Environment-Specific Configuration                                              
                   130

Scaling Your Website                                                            
                             131

Scaling Out with App Clusters                                                   
                    132

Handling Uncaught Exceptions                                                    
                  135

Scaling Out with Multiple Servers                                               
                   138

Monitoring Your Website                                                         
                         139

Third-Party Uptime Monitors                                                     
                   139

Application Failures                                                            
                           140

Stress Testing                                                                  
                                  140

131  Persistence1                                                               
                                          143

Filesystem Persistence                                                          
                             143

Cloud Persistence                                                               
                               145

Database Persistence                                                            
                             146

A Note on Performance                                                           
                      146

Setting Up MongoDB                                                              
                       147

Mongoose                                                                        
                              147

Database Connections with Mongoose                                              
             148

Creating Schemas and Models                                                     
                   149

Seeding Initial Data                                                            
                            150

Retrieving Data                                                                 
                             151

Adding Data                                                                     
                             152


Using MongoDB for Session Storage                                               
               154

141  Routing1                                                                   
                                           157

Routes and SEO                                                                  
                              159

Subdomains                                                                      
                                159

Route Handlers Are Middleware                                                   
                    160

Route Paths and Regular Expressions                                             
                   162

Route Parameters                                                                
                              162

Organizing Routes                                                               
                             163

Declaring Routes in a Module                                                    
                       164

Grouping Handlers Logically                                                     
                       165

Automatically Rendering Views                                                   
                     166

Other Approaches to Route Organization                                          
               167

151  REST APIs and JSON1                                                        
                                     169

JSON and XML                                                                    
                             170

Our API                                                                         
                                   170

API Error Reporting                                                             
                            171

Cross-Origin Resource Sharing (CORS)                                            
                172

Our Data Store                                                                  
                                173

Our Tests                                                                       
                                   173

Using Express to Provide an API                                                 
                      175

Using a REST Plugin                                                             
                            176

Using a Subdomain                                                               
                            178

161  Static Content1                                                            
                                         181

Performance Considerations                                                      
                       182

Future-Proofing Your Website                                                    
                       182

Static Mapping                                                                  
                             183

Static Resources in Views                                                       
                        185

Static Resources in CSS                                                         
                         185

Static Resources in Server-Side JavaScript                                      
                    187

Static Resources in Client-Side JavaScript                                      
                    187

Serving Static Resources                                                        
                            189

Changing Your Static Content                                                    
                       190

Bundling and Minification                                                       
                         190

Skipping Bundling and Minification in Development Mode                          
 193

A Note on Third-Party Libraries                                                 
                      195

QA                                                                              
                                      195

Summary                                                                         
                                 197

171  Implementing MVC in Express1                                               
                               199


Models                                                                          
                                    200

View Models                                                                     
                                201

Controllers                                                                     
                                   203

Conclusion                                                                      
                                  205

181  Security1                                                                  
                                            207

HTTPS                                                                           
                                  207

Generating Your Own Certificate                                                 
                  208

Using a Free Certificate Authority                                              
                    209

Purchasing a Certificate                                                        
                         210

Enabling HTTPS for Your Express App                                             
             212

A Note on Ports                                                                 
                            213

HTTPS and Proxies                                                               
                        214

Cross-Site Request Forgery                                                      
                         215

Authentication                                                                  
                                216

Authentication Versus Authorization                                             
                216

The Problem with Passwords                                                      
                   217

Third-Party Authentication                                                      
                      217

Storing Users in Your Database                                                  
                    218

Authentication Versus Registration and the User Experience                      
    219

Passport                                                                        
                                 220

Role-Based Authorization                                                        
                      229

Adding Additional Authentication Providers                                      
           231

Conclusion                                                                      
                                  232

191  Integrating with Third-Party APIs1                                         
                                233

Social Media                                                                    
                                  233

Social Media Plugins and Site Performance                                       
             233

Searching for Tweets                                                            
                          234

Rendering Tweets                                                                
                          237

Geocoding                                                                       
                                 241

Geocoding with Google                                                           
                      241

Geocoding Your Data                                                             
                        242

Displaying a Map                                                                
                           245

Improving Client-Side Performance                                               
                247

Weather Data                                                                    
                                248

Conclusion                                                                      
                                  249

201  Debugging1                                                                 
                                        251

The First Principle of Debugging                                                
                       251

Take Advantage of REPL and the Console                                          
               252

Using Node1s Built-in Debugger                                                  
                      253


Node Inspector                                                                  
                               253

Debugging Asynchronous Functions                                                
                 257

Debugging Express                                                               
                             257

211  Going Live1                                                                
                                          261

Domain Registration and Hosting                                                 
                    261

Domain Name System                                                              
                     262

Security                                                                        
                                  262

Top-Level Domains                                                               
                         263

Subdomains                                                                      
                             264

Nameservers                                                                     
                             265

Hosting                                                                         
                                 266

Deployment                                                                      
                             269

Conclusion                                                                      
                                  272

221  Maintenance1                                                               
                                       273

The Principles of Maintenance                                                   
                       273

Have a Longevity Plan                                                           
                         273

Use Source Control                                                              
                          275

Use an Issue Tracker                                                            
                           275

Exercise Good Hygiene                                                           
                       275

Don1t Procrastinate                                                             
                           276

Do Routine QA Checks                                                            
                      276

Monitor Analytics                                                               
                           277

Optimize Performance                                                            
                       277

Prioritize Lead Tracking                                                        
                         277

Prevent “Invisible” Failures                                                    
                        279

Code Reuse and Refactoring                                                      
                        279

Private npm Registry                                                            
                          280

Middleware                                                                      
                              281

Conclusion                                                                      
                                  283

231  Additional Resources1                                                      
                                     285

Online Documentation                                                            
                         285

Periodicals                                                                     
                                   286

Stack Overflow                                                                  
                                286

Contributing to Express                                                         
                           288

Conclusion                                                                      
                                  290

Index1                                                                          
                                            291



Foreword

The combination of JavaScript, Node, and Express is an ideal choice for web 
teams that
want a powerful, quick-to-deploy technology stack that is widely respected in 
the de‐
velopment community and large enterprises alike1

Building great web applications and finding great web developers isn1t easy1 
Great apps
require great functionality, user experience, and business impact: delivered, 
deployed,
and supported quickly and cost effectively1 The lower total cost of ownership 
and faster
time-to-market that Express provides is critical in the business world1 If you 
are a web
developer,    you have to use at least some JavaScript1 But you also have the 
option of using
a            lot of it1 In this book, Ethan Brown shows you that you can use a 
lot of it, and it1s not
that hard thanks to Node and Express1

Node and Express are like machine guns that deliver upon the silver-bullet 
promise of
JavaScript1

JavaScript is the most universally accepted language for client-side scripting1 
Unlike
Flash, it1s supported by all major web browsers1 It1s the fundamental 
technology behind
many of the attractive animations and transitions you see on the Web1 In fact, 
it1s almost
impossible  not  to  utilize  JavaScript  if  you  want  to  achieve  modern  
client-side
functionality1

One problem with JavaScript is that it has always been vulnerable to sloppy 
program‐
ming1 The Node ecosystem is changing that by providing frameworks, libraries, 
and
tools that speed up development and encourage good coding habits1 This helps us 
bring
better apps to market faster1

We now have a great programming language that is supported by large 
enterprises, is
easy-to-use, is designed for modern browsers, and is supplemented with great 
frame‐
works and libraries on both client-side and server-side1 I call that 
revolutionary1

—Steve Rosenbaum

President and CEO, Pop Art, Inc1



Preface

Who This Book Is For

Clearly, this book is for programmers who want to create web applications 
(traditional
websites, RESTful APIs, or anything in between) using JavaScript, Node, and 
Express1
One    of the exciting aspects of Node development is that it has attracted a 
whole new
audience of programmers1 The accessibility and flexibility of JavaScript has 
attracted
self-taught programmers from all over the world1 At no time in the history of 
computer
science has programming been so accessible1 The number and quality of online 
resour‐
ces  for learning to program (and getting help when you get stuck) is truly 
astonishing
and inspiring1 So to those new (possibly self-taught) programmers, I welcome 
you1

Then, of course, there are the programmers like me, who have been around for a 
while1
Like many programmers of my era, I started off with assembler and BASIC, and 
went
through Pascal, C++, Perl, Java, PHP, Ruby, C, C#, and JavaScript1 At 
university, I was
exposed to more niche languages such as ML, LISP, and PROLOG1 Many of these lan‐
guages are near and dear to my heart, but in none of these languages do I see 
so much
promise as I do in JavaScript1 So I am also writing this book for programmers 
like myself,
who have a lot of experience, and perhaps a more philosophical outlook on 
specific
technologies1

No experience with Node is necessary, but you should have some experience with 
Java‐
Script1 If you1re new to programming, I recommend Codecademy1 If you1re an 
experi‐
enced  programmer,  I  recommend  Douglas  Crockford1s  JavaScript:  The  Good  
Parts
(O1Reilly)1 The examples in this book can be used with any system that Node 
works on
(which covers Windows, OS X, and Linux)1 The examples are geared toward command-
line (terminal) users, so you should have some familiarity with your system1s 
terminal1

Most important, this book is for programmers who are excited1 Excited about the 
future
of the Internet, and want to be part of it1 Excited about learning new things, 
new tech‐
niques, and new ways of looking at web development1 If, dear reader, you are 
not excited,
I   hope you will be by the time you reach the end of this book…1


How This Book Is Organized

Chapters 1 and 2 will introduce you to Node and Express and some of the tools 
you1ll
be using throughout the book1 In Chapters 3 and 4, you start using Express and 
build
the skeleton of a sample website that will be used as a running example 
throughout the
rest of the book1

Chapter 5 discusses testing and QA, and Chapter 6 covers some of Node1s more im‐
portant constructs and how they are extended and used by Express1 Chapter 7 
covers
templating (using Handlebars), which lays the foundation of building useful 
websites
with Express1 Chapters 8 and 9 cover cookies, sessions, and form handlers, 
rounding
out the things you need to know to build basic functional websites with 
Express1

Chapter 10 delves into “middleware,” a concept central to Connect (one of 
Express1s
major components)1 Chapter 11 explains how to use middleware to send email from
the server and discusses security and layout issues inherent to email1

Chapter 12 offers a preview into production concerns1 Even though, at this 
stage in the
book, you don1t have all the information you need to build a production-ready 
website,
thinking about production now can save you from major headaches in the future1

Chapter 13 is about persistence, with a focus on MongoDB (one of the leading 
document
databases)1

Chapter 14 gets into the details of routing with Express (how URLs are mapped to
content), and Chapter 15 takes a diversion into writing APIs with Express1 
Chapter 16
covers the details of serving static content, with a focus on maximizing 
performance1
Chapter 17 reviews the popular model-view-controller (MVC) paradigm, and how it
fits into Express1

Chapter 18 discusses security: how to build authentication and authorization 
into your
app (with a focus on using a third-party authentication provider), as well as 
how to run
your site over HTTPS1

Chapter 19 explains how to integrate with third-party services1 Examples used 
are Twit‐
ter, Google Maps, and Weather Underground1

Chapters 20 and 21 get your ready for the big day: your site launch1 They cover 
debug‐
ging, so you can root out any defects before launch, and the process of going 
live1
Chapter 22 talks about the next important (and oft-neglected) phase: 
maintenance1

The book concludes with Chapter 23, which points you to additional resources, 
should
you want to further your education about Node and Express, and where you can go 
to
get help1

xvi    |    Preface


Example Website

Starting in Chapter 3, a running example will be used throughout the book: the 
Mead‐
owlark Travel website1 Just having gotten back from a trip to Lisbon, I have 
travel on
my mind, so the example website I have chosen is for a fictional travel company 
in my
home state of Oregon (the Western Meadowlark is the state bird of Oregon)1 
Meadow‐
lark Travel allows travelers to connect to local “amateur tour guides,” and 
partners with
companies offering bike and scooter rentals and local tours1 In addition, it 
maintains a
database of local attractions, complete with history and location-aware 
services1

Like any pedagogical example, the Meadowlark Travel website is contrived, but 
it is an
example that covers many of the challenges facing real-world websites: 
third-party
component integration, geolocation, ecommerce, performance, and security1

As the focus on this book is backend infrastructure, the example website will 
not be
complete; it merely serves as a fictional example of a real-world website to 
provide depth
and context to the examples1 Presumably, you are working on your own website, 
and
you can use the Meadowlark Travel example as a template for it1

Conventions Used in This Book

The following typographical conventions are used in this book:

Italic

Indicates new terms, URLs, email addresses, filenames, and file extensions1

Constant width

Used for program listings, as well as within paragraphs to refer to program 
elements
such as variable or function names, databases, data types, environment 
variables,
statements, and keywords1

Constant width bold

Shows commands or other text that should be typed literally by the user1

Constant width italic

Shows text that should be replaced with user-supplied values or by values deter‐
mined by context1

This element signifies a tip or suggestion1


This element signifies a general note1

This element indicates a warning or caution1

Using Code Examples

Supplemental material (code examples, exercises, etc1) is available for 
download at

https://github1com/EthanRBrown/web-development-with-node-and-express1

This book is here to help you get your job done1 In general, if example code is 
offered
with this book, you may use it in your programs and documentation1 You do not 
need
to contact us for permission unless you1re reproducing a significant portion of 
the code1
For example, writing a program that uses several chunks of code from this book 
does
not require permission1 Selling or distributing a CD-ROM of examples from 
O1Reilly
books does require permission1 Answering a question by citing this book and 
quoting
example code does not require permission1 Incorporating a significant amount of 
ex‐
ample code from this book into your product1s documentation does require 
permission1

We appreciate, but do not require, attribution1 An attribution usually includes 
the title,
author, publisher, and ISBN1 For example: “Web Development with Node and Express
by Ethan Brown (O1Reilly)1 Copyright 2014 Ethan Brown, 978-1-491-94930-61”

If you feel your use of code examples falls outside fair use or the permission 
given above,
feel free to contact us at permissions@oreilly1com1

Safari® Books Online

Safari  Books  Online  is  an  on-demand  digital  library  that
delivers expert content in both book and video form from
the world1s leading authors in technology and business1

Technology professionals, software developers, web designers, and business and 
crea‐
tive professionals use Safari Books Online as their primary resource for 
research, prob‐
lem solving, learning, and certification training1

Safari Books Online offers a range of product mixes and pricing programs for 
organi‐
zations, government agencies, and individuals1 Subscribers have access to 
thousands of
books, training videos, and prepublication manuscripts in one fully searchable 
database


from publishers like O1Reilly Media, Prentice Hall Professional, Addison-Wesley 
Pro‐
fessional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco 
Press, John
Wiley   & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT
Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course 
Technol‐
ogy, and dozens more1 For more information about Safari Books Online, please 
visit us
online1

How to Contact Us

Please address comments and questions concerning this book to the publisher:

O1Reilly Media, Inc1

1005 Gravenstein Highway North
Sebastopol, CA 95472

800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)

707-829-0104 (fax)

We have a web page for this book, where we list errata, examples, and any 
additional
information1 You can access this page at http://bit1ly/web_dev_node_express1

To  comment  or  ask  technical  questions  about  this  book,  send  email  to 
 bookques
tions@oreilly1com1

For more information about our books, courses, conferences, and news, see our 
website
at http://www1oreilly1com1

Find us on Facebook: http://facebook1com/oreilly

Follow us on Twitter: http://twitter1com/oreillymedia

Watch us on YouTube: http://www1youtube1com/oreillymedia

Acknowledgments

So many people in my life have played a part in making this book a reality: it 
would not
have been possible without the influence of all the people who have touched my 
life and
made me who I am today1

I would like to start out by thanking everyone at Pop Art: not only has my time 
at Pop
Art given me a renewed passion for engineering, but I have learned so much from
everyone there, and without their support, this book would not exist1 I am 
grateful to
Steve Rosenbaum for creating an inspiring place to work, and to Del Olds for 
bringing
me on board, making me feel welcome, and being an honorable leader1 Thanks to 
Paul
Inman for his unwavering support and inspiring attitude toward engineering, and 
Tony
Alferez for his warm support and for helping me carve out time for writing 
without


impacting Pop Art1 Finally, thanks to all the great engineers I have worked 
with, who
keep me on my toes: John Skelton, Dylan Hallstrom, Greg Yung, Quinn Michael, and
CJ Stritzel1

Zach Mason, thank you for being an inspiration to me1 This book may be no The 
Lost
Books of the Odyssey, but it is mine, and I don1t know if I would have been so 
bold without
your example1

I owe everything to my family1 I couldn1t have wished for a better, more loving 
education
than the one they gave me, and I see their exceptional parenting reflected in 
my sister
too1

Many thanks to Simon St1 Laurent for giving me this opportunity, and to Brian 
Anderson
for his steady and encouraging editing1 Thanks to everyone at O1Reilly for 
their dedi‐
cation and passion1 Thanks to Jennifer Pierce, Mike Wilson, Ray Villalobos, and 
Eric
Elliot for their thorough and constructive technical reviews1

Katy Roberts and Hanna Nelson provided invaluable feedback and advice on my 
“over
the transom” proposal that made this book possible1 Thank you both so much! 
Thanks
to Chris Cowell-Shah for his excellent feedback on the QA chapter1

Lastly, thanks to my dear friends, without whom I surely would have gone 
insane1 Byron
Clayton, Mark Booth, Katy Roberts, and Sarah Lewis, you are the best group of 
friends
a      man could ask for1 And thanks to Vickey and Judy, just for being who 
they are1 I love
you all1


CHAPTER 1

Introducing Express

The JavaScript Revolution

Before I introduce the main subject of this book, it is important to provide a 
little back‐
ground and historical context, and that means talking about JavaScript and 
Node1

The age of JavaScript is truly upon us1 From its humble beginnings as a 
client-side
scripting language, not only has it become completely ubiquitous on the client 
side, but
its      use as a server-side language has finally taken off too, thanks to 
Node1

The promise of an all-JavaScript technology stack is clear: no more context 
switching!
No longer do you have to switch mental gears from JavaScript to PHP, C#, Ruby, 
or
Python (or any other server-side language)1 Furthermore, it empowers frontend 
engi‐
neers to make the jump to server-side programming1 This is not to say that 
server-side
programming is strictly about the language: there1s still a lot to learn1 With 
JavaScript,
though,        at least the language won1t be a barrier1

This book is for all those who see the promise of the JavaScript technology 
stack1 Perhaps
you are a frontend engineer looking to extend your experience into backend 
develop‐
ment1 Perhaps you1re an experienced backend developer like myself who is 
looking to
JavaScript as a viable alternative to entrenched server-side languages1

If you1ve been a software engineer for as long as I have, you have seen many 
languages,
frameworks, and APIs come into vogue1 Some have taken off, and some have faded 
into
obsolescence1 You probably take pride in your ability to rapidly learn new 
languages,
new  systems1 Every new language you come across feels a little more familiar: 
you
recognize a bit here from a language you learned in college, a bit there from 
that job
you     had a few years ago1 It feels good to have that kind of perspective, 
certainly, but it1s
also wearying1 Sometimes you want to just get something done, without having to 
learn
a whole new technology or dust off skills you haven1t used in months or years1


JavaScript may seem, at first, an unlikely champion1 I sympathize, believe me1 
If you
told me three years ago that I would not only come to think of JavaScript as my 
language
of choice, but also write a book about it, I would have told you you were 
crazy1 I had all
the usual prejudices against JavaScript: I thought it was a “toy” language1 
Something for
amateurs and dilettantes to mangle and abuse1 To be fair, JavaScript did lower 
the bar
for amateurs, and there was a lot of questionable JavaScript out there, which 
did not
help the language1s reputation1 To turn a popular saying on its head, “Hate the 
player,
not the game1”

It is unfortunate that people suffer this prejudice against JavaScript: it has 
prevented
people from discovering how powerful, flexible, and elegant the language is1 
Many peo‐
ple are just now starting to take JavaScript seriously, even though the 
language as we
know it now has been around since 1996 (although many of its more attractive 
features
were added in 2005)1

By picking up this book, you are probably free of that prejudice: either 
because, like me,
you have gotten past it, or because you never had it in the first place1 In 
either case, you
are fortunate, and I look forward to introducing you to Express, a technology 
made
possible by a delightful and surprising language1

In  2009,  years  after  people  had  started  to  realize  the  power  and  
expressiveness  of
JavaScript as a browser scripting language, Ryan Dahl saw JavaScript1s 
potential as a
server-side language, and Node was born1 This was a fertile time for Internet 
technology1
Ruby (and Ruby on Rails) took some great ideas from academic computer science,
combined them with some new ideas of its own, and showed the world a quicker way
to build websites and web applications1 Microsoft, in a valiant effort to 
become relevant
in the Internet age, did amazing things with 1NET and learned not only from 
Ruby and
JavaScript, but also from Java1s mistakes, while borrowing heavily from the 
halls of
academia1

It is an exciting time to be involved in Internet technology1 Everywhere, there 
are amaz‐
ing new ideas (or amazing old ideas revitalized)1 The spirit of innovation and 
excitement
is greater now than it has been in many years1

Introducing Express

The Express website describes Express as “a minimal and flexible node1js web 
applica‐
tion framework, providing a robust set of features for building single and 
multipage
and hybrid web applications1” What does that really mean, though? Let1s break 
that
description down:

Minimal

This is one of the most appealing aspects of Express1 Many times, framework de‐
velopers forget that usually “less is more1” The Express philosophy is to 
provide the
minimal layer between your brain and the server1 That doesn1t mean that it1s 
not


robust, or that it doesn1t have enough useful features1 It means that it gets 
in your
way less, allowing you full expression of your ideas, while at the same time 
providing
something useful1

Flexible

Another key aspect of the Express philosophy is that Express is extensible1 
Express
provides you a very minimal framework, and you can add in different parts of
Express functionality as needed, replacing whatever doesn1t meet your needs1 
This
is         a breath of fresh air1 So many frameworks give you everything, 
leaving you with
a bloated, mysterious, and complex project before you1ve even written a single 
line
of code1 Very often, the first task is to waste time carving off unneeded 
functionality,
or replacing the functionality that doesn1t meet requirements1 Express takes the
opposite approach, allowing you to add what you need when you need it1

Web application framework

Here1s where semantics starts to get tricky1 What1s a web application? Does that
mean you can1t build a website or web pages with Express? No, a website is a web
application, and a web page is a web application1 But a web application can be 
more:
it        can provide functionality to other web applications (among other 
things)1 In
general, “app” is used to signify something that has functionality: it1s not 
just a static
collection of content (though that is a very simple example of a web app)1 While
there      is currently a distinction between an “app” (something that runs 
natively on
your device) and a “web page” (something that is served to your device over the
network), that distinction is getting blurrier, thanks to projects like 
PhoneGap, as
well      as Microsoft1s move to allow HTML5 applications on the desktop, as if 
they
were native applications1 It1s easy to imagine that in a few years, there won1t 
be a
distinction between an app and a website1

Single-page web applications

Single-page web applications are a relatively new idea1 Instead of a website 
requiring
a network request every time the user navigates to a different page, a 
single-page
web application downloads the entire site (or a good chunk of it) to the 
client1s
browser1 After that initial download, navigation is faster because there is 
little or no
communication with the server1 Single-page application development is 
facilitated
by                               the use of popular frameworks such as Angular 
or Ember, which Express is happy
to serve up1

Multipage and hybrid web applications

Multipage web applications are a more traditional approach to websites1 Each 
page
on a website is provided by a separate request to the server1 Just because this 
ap‐
proach is more traditional does not mean it is not without merit or that 
single-page
applications are somehow better1 There are simply more options now, and you can
decide what parts of your content should be delivered as a single-page app, and


what parts should be delivered via individual requests1 “Hybrid” describes 
sites that
utilize both of these approaches1

If you1re still feeling confused about what Express actually is, don1t worry: 
sometimes
it1s much easier to just start using something to understand what it is, and 
this book will
get you started building web applications with Express1

A Brief History of Express

Express1s creator, TJ Holowaychuk, describes Express as a web framework 
inspired by
Sinatra, which is a web framework based on Ruby1 It is no surprise that Express 
borrows
from a framework built on Ruby: Ruby spawned a wealth of great approaches to web
development,  aimed  at  making  web  development  faster,  more  efficient,  
and  more
maintainable1

As much as Express was inspired by Sinatra, it is also deeply intertwined with 
Connect,
a “plugin” library for Node1 Connect coined the term “middleware” to describe 
pluggable
Node modules that can handle web requests to varying degrees1 Up until version 
410,
Express bundled Connect; in version 410, Connect (and all middleware except 
static)
was removed to allow these middleware to be updated independently1

Express underwent a fairly substantial rewrite between 21x and 310,
then again between 31x and 4101 This book will focus on version 4101

Upgrading to Express 410

If you already have some experience with Express 310, you1ll be happy to learn 
that
upgrading to Express 410 is pretty painless1 If you1re new to Express, you can 
skip this
section1 Here are the high points for those with Express 310 experience:

•  Connect has been removed from Express, so with the exception of the static
middleware, you will need to install the appropriate packages (namely, connect)1
At the same time, Connect has been moving some of its middleware into their own
packages, so you might have to do some searching on npm to figure out where your
middleware went1

•  body-parser is now its own package, which no longer includes the multipart
middleware, closing a major security hole1 It1s now safe to use the body-parser
middleware1

•  You no longer have to link the Express router into your application1 So you 
should
remove app1use(app1router) from your existing Express 310 apps1


•  app1configure was removed; simply replace calls to this method by examining

app1get(env) (using either a switch statement or if statements)1

For more details, see the official migration guide1

Express is an open source project and continues to be primarily developed and 
main‐
tained by TJ Holowaychuk1

Node: A New Kind of Web Server

In a way, Node has a lot in common with other popular web servers, like 
Microsoft1s
Internet Information Services (IIS) or Apache1 What is more interesting, 
though, is how
it differs, so let1s start there1

Much  like  Express,  Node1s  approach  to  webservers  is  very  minimal1  
Unlike  IIS  or
Apache, which a person can spend many years mastering, Node is very easy to set 
up
and configure1 That is not to say that tuning Node servers for maximum 
performance
in a production setting is a trivial matter: it1s just that the configuration 
options are
simpler and more straightforward1

Another major difference between Node and more traditional web servers is that 
Node
is single threaded1 At first blush, this may seem like a step backward1 As it 
turns out, it
is a stroke of genius1 Single threading vastly simplifies the business of 
writing web apps,
and if you need the performance of a multithreaded app, you can simply spin up 
more
instances of Node, and you will effectively have the performance benefits of 
multi‐
threading1 The astute reader is probably thinking this sounds like smoke and 
mirrors1
After      all, isn1t multithreading through server parallelism (as opposed to 
app parallelism)
simply moving the complexity around, not eliminating it? Perhaps, but in my 
experi‐
ence, it has moved the complexity to exactly where it should be1 Furthermore, 
with the
growing popularity of cloud computing and treating servers as generic 
commodities,
this approach makes a lot more sense1 IIS and Apache are powerful indeed, and 
they
are designed to squeeze the very last drop of performance out of today1s 
powerful hard‐
ware1 That comes at a cost, though: they require considerable expertise to set 
up and
tune to achieve that performance1

In terms of the way apps are written, Node apps have more in common with PHP or
Ruby apps than 1NET or Java apps1 While the JavaScript engine that Node uses 
(Google1s
V8) does compile JavaScript to native machine code (much like C or C++), it 
does so
transparently,1  so from the user1s perspective, it behaves like a purely 
interpreted lan‐
guage1              Not having a separate compile step reduces maintenance and 
deployment hassles:
all you have to do is update a JavaScript file, and your changes will 
automatically be
available1

11  Often called “Just in Time” (JIT) compilation1


Another compelling benefit of Node apps is that Node is incredibly platform 
inde‐
pendent1 It1s not the first or only platform-independent server technology, but 
platform
independence is really more of a spectrum than a binary proposition1 For 
example, you
can        run 1NET apps on a Linux server thanks to Mono, but it1s a painful 
endeavor1
Likewise, you can run PHP apps on a Windows server, but it is not generally as 
easy to
set        up as it is on a Linux machine1 Node, on the other hand, is a snap 
to set up on all the
major operating systems (Windows, OS X, and Linux) and enables easy 
collaboration1
Among website design teams, a mix of PCs and Macs is quite common1 Certain plat‐
forms, like 1NET, introduce challenges for frontend developers and designers, 
who often
use Macs, which has a huge impact on collaboration and efficiency1 The idea of 
being
able to spin up a functioning server on any operating system in a matter of 
minutes (or
even seconds!) is a dream come true1

The Node Ecosystem

Node, of course, lies at the heart of the stack1 It1s the software that enables 
JavaScript to
run on the server, uncoupled from a browser, which in turn allows frameworks 
written
in JavaScript (like Express) to be used1 Another important component is the 
database,
which will be covered in more depth in Chapter 131 All but the simplest of web 
apps
will need a database, and there are databases that are more at home in the Node 
eco‐
system than others1

It is unsurprising that database interfaces are available for all the major 
relational da‐
tabases (MySQL, MariaDB, PostgreSQL, Oracle, SQL Server): it would be foolish to
neglect those established behemoths1 However, the advent of Node development has
revitalized a new approach to database storage: the so-called “NoSQL” 
databases1 It1s not
always helpful to define something as what it1s not, so we1ll add that these 
NoSQL da‐
tabases might be more properly called “document databases” or “key/value pair 
data‐
bases1” They provide a conceptually simpler approach to data storage1 There are 
many,
but MongoDB is one of the frontrunners, and the one we will be using in this 
book1

Because building a functional website depends on multiple pieces of technology, 
acro‐
nyms have been spawned to describe the “stack” that a website is built on1 For 
example,
the combination of Linux, Apache, MySQL, and PHP is referred to as the LAMP 
stack1
Valeri Karpov, an engineer at MongoDB, coined the acronym MEAN: Mongo, Express,
Angular, and Node1 While it1s certainly catchy, it is limiting: there are so 
many choices
for databases and application frameworks that “MEAN” doesn1t capture the 
diversity of
the ecosystem (it also leaves out what I believe is an important component: 
templating
engines)1

Coining an inclusive acronym is an interesting exercise1 The indispensable 
component,
of course, is Node1 While there are other server-side JavaScript containers, 
Node is
emerging as the dominant one1 Express, also, is not the only web app framework 
avail‐
able, though it is close to Node in its dominance1 The two other components 
that are


usually essential for web app development are a database server and a 
templating engine
(a templating engine provides what PHP, JSP, or Razor provides naturally: the 
ability to
seamlessly combine code and markup output)1 For these last two components, there
aren1t     as many clear frontrunners, and this is where I believe it1s a 
disservice to be re‐
strictive1

What ties all these technologies together is JavaScript, so in an effort to be 
inclusive, I
will be referring to the “JavaScript stack1” For the purposes of this book, 
that means
Node, Express, and MongoDB1

Licensing

When developing Node applications, you may find yourself having to pay more 
atten‐
tion to licensing than you ever have before (I certainly have)1 One of the 
beauties of the
Node ecosystem is the vast array of packages available to you1 However, each of 
those
packages carries its own licensing, and worse, each package may depend on other 
pack‐
ages, meaning that understanding the licensing of the various parts of the app 
you1ve
written can be tricky1

However, there is some good news1 One of the most popular licenses for Node 
packages
is the MIT license, which is painlessly permissive, allowing you to do almost 
anything
you want, including use the package in closed source software1 However, you 
shouldn1t
just assume every package you use is MIT licensed1

There are several packages available in npm that will try to figure out
the  licenses  of  each  dependency  in  your  project1  Search  npm  for
license-sniffer or license-spelunker1

While MIT is the most common license you will encounter, you may also see the 
fol‐
lowing licenses:

GNU General Public License (GPL)

The GPL is a very popular open source license that has been cleverly crafted to 
keep
software free1 That means if you use GPL-licensed code in your project, your 
project
must also be GPL licensed1 Naturally, this means your project can1t be closed 
source1

Apache 210

This license, like MIT, allows you to use a different license for your project, 
includ‐
ing a closed source license1 You must, however, include notice of components 
that
use the Apache 210 license1


Berkeley Software Distribution (BSD)

Similar to Apache, this license allows you to use whatever license you wish for 
your
project, as long as you include notice of the BSD-licensed components1

Software  is  sometimes  dual  licensed  (licensed  under  two  different
licenses)1 A very common reason for doing this is to allow the soft‐
ware   to be used in both GPL projects and projects with more per‐
missive licensing1 (For a component to be used in GPL software, the
component must be GPL licensed1) This is a licensing scheme I often
employ with my own projects: dual licensing with GPL and MIT1

Lastly, if you find yourself writing your own packages, you should be a good 
citizen and
pick a license for your package, and document it correctly1 There is nothing 
more frus‐
trating to a developer than using someone1s package and having to dig around in 
the
source to determine the licensing or, worse, find that it isn1t licensed at 
all1


CHAPTER 2

Getting Started with Node

If you don1t have any experience with Node, this chapter is for you1 
Understanding
Express and its usefulness requires a basic understanding of Node1 If you 
already have
experience building web apps with Node, feel free to skip this chapter1 In this 
chapter,
we        will be building a very minimal web server with Node; in the next 
chapter, we will
see how to do the same thing with Express1

Getting Node

Getting Node installed on your system couldn1t be easier1 The Node team has 
gone to
great lengths to make sure the installation process is simple and 
straightforward on all
major platforms1

The installation is so simple, as a matter of fact, that it can be summed up in 
three simple
steps:

11  Go to the Node home page1

21  Click the big green button that says INSTALL1

31  Follow instructions1

For Windows and OS X, an installer will be downloaded that walks you through the
process1 For Linux, you will probably be up and running more quickly if you use 
a
package manager1

If you1re a Linux user and you do want to use a package manager,
make sure you follow the instructions in the aforementioned web
page1  Many  Linux  distributions  will  install  an  extremely  old  ver‐
sion of Node if you don1t add the appropriate package repository1


You can also download a standalone installer, which can be helpful if you are 
distributing
Node to your organization1

If you have trouble building Node, or for some reason you would like to build 
Node
from scratch, please refer to the official installation instructions1

Using the Terminal

I1m an unrepentant fan of the power and productivity of using a terminal (also 
called a
“console” or “command prompt”)1 Throughout this book, all examples will assume
you1re using a terminal1 If you1re not friends with your terminal, I highly 
recommend
you spend some time familiarizing yourself with your terminal of choice1 Many 
of the
utilities in this book have corresponding GUI interfaces, so if you1re dead set 
against
using a terminal, you have options, but you will have to find your own way1

If you1re on OS X or Linux, you have a wealth of venerable shells (the terminal 
command
interpreter) to choose from1 The most popular by far is bash, though zsh has 
its adher‐
ents1      The main reason I gravitate toward bash (other than long 
familiarity) is ubiquity1
Sit down in front of any Unix-based computer, and 99% of the time, the default 
shell
will be bash1

If you1re a Windows user, things aren1t quite so rosy1 Microsoft has never been 
partic‐
ularly interested in providing a pleasant terminal experience, so you1ll have 
to do a little
more work1 Git helpfully includes a “Git bash” shell, which provides a 
Unix-like terminal
experience (it only has a small subset of the normally available Unix 
command-line
utilities, but it1s a useful subset)1 While Git bash provides you with a 
minimal bash shell,
it1s   still using the built-in Windows console application, which leads to an 
exercise in
frustration (even simple functionaity like resizing a console window, selecting 
text, cut‐
ting,     and pasting is unintuitive and awkward)1 For this reason, I recommend 
installing
a more sophisticated terminal such as Console2 or ConEmu1 For Windows power 
users

—especially for 1NET developers or for hardcore Windows systems or network 
admin‐
istrators—there is another option: Microsoft1s own PowerShell1 PowerShell lives 
up to
its name: people do remarkable things with it, and a skilled PowerShell user 
could give
a Unix command-line guru a run for their money1 However, if you move between OS
X/Linux and Windows, I still recommend sticking with Git bash for the 
consistency it
provides1

Another option, if you1re a Windows user, is virtualization1 With the power and 
archi‐
tecture of modern computers, the performance of virtual machines (VMs) is 
practically
indistinguishable from actual machines1 I1ve had great luck with Oracle1s free 
Virtual‐
Box,                   and Windows 8 offers VM support built in1 With 
cloud-based file storage, such as
Dropbox, and the easy bridging of VM storage to host storage, virtualizing is 
looking
more attractive all the time1 Instead of using Git bash as a bandage on 
Windows1s
lackluster console support, consider using a Linux VM for development1 If you 
find the


UI isn1t as smooth as you would like, you could use a terminal application, 
such as
PuTTY, which is what I often do1

Finally, no matter what sytem you1re on, there1s the excellent Codio1 Codio is 
a website
that will spin up a new Linux instance for every project you have and provide 
an IDE
and command line, with Node already installed1 It1s extremely easy to use and 
is a great
way to get started very quickly with Node1

When you specify the -g (global) option when installing npm pack‐
ages,  they  are  installed  in  a  subdirectory  of  your  Windows  home
directory1 I1ve found that a lot of these packages don1t perform well if
there   are spaces in your username (my username used to be “Ethan
Brown,” and now it1s “ethan1brown”)1 For your sanity, I recommend
choosing a Windows username without a space in it1 If you already
have such a username, it1s advisable to create a new user, and then
transfer your files over to the new account: trying to rename your
Windows home directory is possible but fraught with danger1

Once you1ve settled on a shell that makes you happy, I recommend you spend some 
time
getting to know the basics1 There are many wonderful tutorials on the Internet, 
and
you1ll save yourself a lot of headaches later on by learning a little now1 At 
minimum,
you should know how to navigate directories; copy, move, and delete files; and 
break
out of a command-line program (usually Ctrl-C)1 If you want to become a terminal
ninja, I encourage you to learn how to search for text in files, search for 
files and direc‐
tories, chain commands together (the old “Unix philosophy”), and redirect 
output1

On many Unix-like systems, Ctrl-S has a special meaning: it will
“freeze” the terminal (this was once used to pause output quickly
scrolling past)1 Since this is such a common shortcut for Save, it1s
very  easy  to  unthinkingly  press,  which  leads  to  a  very  confusing
situation for most people (this happens to me more often than I care
to admit)1 To unfreeze the terminal, simply hit Ctrl-Q1 So if you1re
ever confounded by a terminal that seems to have suddenly frozen,
try pressing Ctrl-Q and see if it releases it1

Editors

Few topics inspire such heated debate among programmers as the choice of 
editors, and
for good reason: the editor is your primary tool1 My editor of choice is vi1 
(or an editor
that has a vi mode)1 vi isn1t for everyone (my coworkers constantly roll their 
eyes at me

11  These days, vi is essentially synonymous with vim (vi improved)1 On most 
systems, vi is aliased to vim, but
I usually type vim to make sure I1m using vim1


when I tell them how easy it would be to do what they1re doing in vi), but 
finding a
powerful editor and learning to use it will significantly increase your 
productivity and,
dare I say it, enjoyment1 One of the reasons I particularly like vi (though 
hardly the most
important reason) is that like bash, it is ubiquitous1 If you have access to a 
Unix system
(Cygwin included), vi is there for you1 Many popular editors (even Microsoft 
Visual
Studio!) have a vi mode1 Once you get used to it, it1s hard to imagine using 
anything
else1 vi is a hard road at first, but the payoff is worth it1

If, like me, you see the value in being familiar with an editor that1s 
available anywhere,
your other option is Emacs1 Emacs and I have never quite gotten on (and usually 
you1re
either an Emacs person or a vi person), but I absolutely respect the power and 
flexibility
that Emacs provides1 If vi1s modal editing approach isn1t for you, I would 
encourage you
to look into Emacs1

While knowing a console editor (like vi or Emacs) can come in incredibly handy, 
you
may still want a more modern editor1 Some of my frontend colleagues swear by 
Coda,
and I trust their opinion1 Unfortunately, Coda is available only on OS X1 
Sublime Text
is   a modern and powerful editor that also has an excellent vi mode, and it1s 
available on
Windows, Linux, and OS X1

On Windows, there are some fine free options out there1 TextPad and Notepad++ 
both
have their supporters1 They1re both capable editors, and you can1t beat the 
price1 If you1re
a Windows user, don1t overlook Visual Studio as a JavaScript editor: it1s 
remarkably
capable, and has one of the best JavaScript autocomplete engines of any editor1 
You can
download Visual Studio Express from Microsoft for free1

npm

npm is the ubiquitous package manager for Node packages (and is how we1ll get 
and
install Express)1 In the wry tradition of PHP, GNU, WINE, and others, “npm” is 
not an
acronym (which is why it isn1t capitalized); rather, it is a recursive 
abbreviation for “npm
is       not an acronym1”

Broadly speaking, a package manager1s two primary responsibilities are 
installing pack‐
ages and manging dependencies1 npm is a fast, capable, and painless package 
manager,
which I feel is in large part responsible for the rapid growth and diversity of 
the Node
ecosystem1

npm is installed when you install Node, so if you followed the steps listed 
earlier, you1ve
already got it1 So let1s get to work!


The primary command you1ll be using with npm (unsurprisingly), is install1 For 
ex‐
ample, to install Grunt (a popular JavaScript task runner), you would issue the 
following
command (on the console):

npm install -g grunt-cli

The -g flag tells npm to install the package globally, meaning it1s available 
globally on
the system1 This distinction will become clearer when we cover the package1json 
files1
For now, the rule of thumb is that JavaScript utilities (like Grunt) will 
generally be
installed globally, whereas packages that are specific to your web app or 
project will not1

Unlike languages like Python—which underwent a major language
change from 210 to 310, necessitating a way to easily switch between
different environments—the Node platform is new enough that it is
likely that you should always be running the latest version of Node1
However, if you do find yourself needing to support multiple ver‐
sion       of  Node,  there  is  a  project,  nvm,  that  allows  you  to  
switch
environments1

A Simple Web Server with Node

If you1ve ever built a static HTML website before, or are coming from a PHP or 
ASP
background, you1re probably used to the idea of the web server (Apache or IIS, 
for
example) serving your static files so that a browser can view them over the 
network1 For
example, if you create the file about1html, and put it in the proper directory, 
you can
then navigate to http://localhost/about1html1 Depending on your web server 
configu‐
ration, you might even be able to omit the 1html, but the relationship between 
URL and
filename is clear: the web server simply knows where the file is on the 
computer, and
serves it to the browser1

localhost, as the name implies, refers to the computer you1re on1 This
is a common alias for the IPv4 loopback address 127101011, or the IPv6
loopback address ::11 You will often see 127101011 used instead, but I
will       be using localhost in this book1 If you1re using a remote computer
(using SSH, for example), keep in mind that browsing to localhost will
not connect to that computer1

Node offers a different paradigm than that of a traditional web server: the app 
that you
write is the web server1 Node simply provides the framework for you to build a 
web
server1

“But I don1t want to write a web server,” you might be saying! It1s a natural 
response: you
want to be writing an app, not a web server1 However, Node makes the business 
of writing


this web server a simple affair (just a few lines, even) and the control you 
gain over your
application in return is more than worth it1

So let1s get to it1 You1ve installed Node, you1ve made friends with the 
terminal, and now
you1re ready to go1

Hello World

I1ve always found it unfortunate that the canonical introductory programming 
example
is the uninspired message “Hello World1” However, it seems almost sacrilegious 
at this
point to fly in the face of such ponderous tradition, so we1ll start there, and 
then move
on  to something more interesting1

In your favorite editor, create a file called helloWorld1js:

var http = require('http');

http1createServer(function(req,res){

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('Hello world!');

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

Make  sure  you  are  in  the  same  directory  as  helloWorld1js,  and  type  
node hello
World1js1 Then open up a browser and navigate to http://localhost:3000, and 
voil! Your
first web server1 This particular one doesn1t serve HTML; rather, it just 
transmits the
message “Hello world!” in plaintext to your browser1 If you want, you can 
experiment
with sending HTML instead: just change text/plain to text/html and change 'Hello
world!' to a string containing valid HTML1 I didn1t demonstrate that, because I 
try to
avoid writing HTML inside JavaScript for reasons that will be discussed in more 
detail
in Chapter 71

Event-Driven Programming

The core philosophy behind Node is that of event-driven programming1 What that 
means
for you, the programmer, is that you have to understand what events are 
available to
you and how to respond to them1 Many people are introduced to event-driven pro‐
gramming by implementing a user interface: the user clicks on something, and you
handle  the “click event1” It1s a good metaphor, because it1s understood that 
the program‐
mer has no control over when, or if, the user is going to click something, so 
event-driven
programming is really quite intuitive1 It can be a little harder to make the 
conceptual
leap               to responding to events on the server, but the principle is 
the same1

In the previous code example, the event is implicit: the event that1s being 
handled is an
HTTP request1 The http1createServer method takes a function as an argument; 
that


function will be invoked every time an HTTP request is made1 Our simple program 
just
sets the content type to plaintext and sends the string “Hello world!”

Routing

Routing refers to the mechanism for serving the client the content it has asked 
for1 For
web-based client/server applications, the client specifies the desired content 
in the URL;
specifically, the path and querystring (the parts of a URL will be discussed in 
more detail
in Chapter 6)1

Let1s expand our “Hello world!” example to do something more interesting1 Let1s 
serve
a really minimal website consisting of a home page, an About page, and a Not 
Found
page1 For now, we1ll stick with our previous example and just serve plaintext 
instead of
HTML:

var http = require('http');

http1createServer(function(req,res){

// normalize url by removing querystring, optional

// trailing slash, and making it lowercase

var path = req1url1replace(/\/?(?:\?1*)?$/, '')1toLowerCase();

switch(path) {

case '':

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('Homepage');

break;
case '/about':

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('About');

break;
default:

res1writeHead(404, { 'Content-Type': 'text/plain' });
res1end('Not Found');

break;

}

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

If you run this, you1ll find you can now browse to the home page 
(http://localhost:
3000) and the About page (http://localhost:3000/about)1 Any querystrings will 
be ig‐
nored (so http://localhost:3000/?foo=bar will serve the home page), and any 
other URL
(http://localhost:3000/foo) will serve the Not Found page1

Serving Static Resources

Now that we1ve got some simple routing working, let1s serve some real HTML and a
logo image1 These are called “static resources” because they don1t change (as 
opposed
to, for example, a stock ticker: every time you reload the page, the stock 
prices change)1


Serving static resources with Node is suitable for developent and small
projects, but for larger projects, you will probably want to use a proxy
server such as Nginx or a CDN to serve static resources1 See Chap‐
ter  16 for more information1

If you1ve worked with Apache or IIS, you1re probably used to just creating an 
HTML
file, navigating to it, and having it delivered to the browser automatically1 
Node doesn1t
work like that: we1re going to have to do the work of opening the file, reading 
it, and
then sending its contents along to the browser1 So let1s create a directory in 
our project
called public (why we don1t call it static will become evident in the next 
chapter)1 In that
directory,  we1ll  create  home1html,  about1html,  notfound1html,  a  
subdirectory  called
img,   and an image called img/logo1jpg1 I1ll leave that up to you: if you1re 
reading this
book, you probably know how to write an HTML file and find an image1 In your 
HTML
files, reference the logo thusly: <img href="/img/logo1jpg" alt="logo">1

Now modify helloWorld1js:

var http = require('http'),
fs = require('fs');

function serveStaticFile(res, path, contentType, responseCode) {

if(!responseCode) responseCode = 200;

fs1readFile(  dirname + path, function(err,data) {

if(err) {

res1writeHead(500, { 'Content-Type': 'text/plain' });
res1end('500 - Internal Error');

} else {

res1writeHead(responseCode,

{ 'Content-Type': contentType });
res1end(data);

}

});

}

http1createServer(function(req,res){

// normalize url by removing querystring, optional

// trailing slash, and making lowercase

var path = req1url1replace(/\/?(?:\?1*)?$/, '')

1toLowerCase();

switch(path) {

case '':

serveStaticFile(res, '/public/home1html', 'text/html');

break;
case '/about':

serveStaticFile(res, '/public/about1html', 'text/html');

break;

case '/img/logo1jpg':

serveStaticFile(res, '/public/img/logo1jpg',


'image/jpeg');

break;
default:

serveStaticFile(res, '/public/4041html', 'text/html',
404);

break;

}

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

In this example, we1re being pretty unimaginative with our routing1
If you navigate to http://localhost:3000/about, the public/about1html
file is served1 You could change the route to be anything you want,
and change the file to be anything you want1 For example, if you had
a different About page for each day of the week, you could have files
public/about_mon1html, public/about_tue1html, and so on, and pro‐
vide logic in your routing to serve the appropriate page when the user
navigates to http://localhost:3000/about1

Note we1ve created a helper function, serveStaticFile, that1s doing the bulk of 
the
work1 fs1readFile is an asynchronous method for reading files1 There is a 
synchronous
version of that function, fs1readFileSync, but the sooner you start thinking 
asyn‐
chronously, the better1 The function is simple: it calls fs1readFile to read 
the contents
of             the specified file1 fs1readFile executes the callback function 
when the file has been
read; if the file didn1t exist or there were permissions issues reading the 
file, the err
variable is set, and the function returns an HTTP status code of 500 indicating 
a server
error1   If the file is read successfully, the file is sent to the client with 
the specified response
code and content type1 Response codes will be discussed in more detail in 
Chapter 61

  dirname will resolve to the directory the executing script resides in1
So if your script resides in /home/sites/app1js,     dirname will resolve
to  /home/sites1  It1s  a  good  idea  to  use  this  handy  global  whenever
possible1 Failing to do so can cause hard-to-diagnose errors if you run
your app from a different directory1

Onward to Express

So far, Node probably doesn1t seem that impressive to you1 We1ve basically 
replicated
what Apache or IIS do for you automatically, but now you have some insight into 
how
Node does things and how much control you have1 We haven1t done anything 
particu‐
larly impressive, but you can see how we could use this as a jumping-off point 
to do
more sophisticated things1 If we continued down this road, writing more and 
more


sophisticated Node applications, you might very well end up with something that 
re‐
sembles Express…1

Fortunately, we don1t have to: Express already exists, and it saves you from 
implementing
a lot of time-consuming infrastructure1 So now that we1ve gotten a little Node 
experience
under our belt, we1re ready to jump into learning Express1


CHAPTER 3

Saving Time with Express

In Chapter 2, you learned how to create a simple web server using only Node1 In 
this
chapter, we will recreate that server using Express1 This will provide a 
jumping-off point
for   the rest of the content of this book and introduce you to the basics of 
Express1

Scaffolding

Scaffolding is not a new idea, but many people (myself included) were 
introduced to
the concept by Ruby1 The idea is simple: most projects require a certain amount 
of so-
called “boilerplate” code, and who wants to recreate that code every time you 
begin a
new project? A simple way is to create a rough skeleton of a project, and every 
time you
need a new project, you just copy this skeleton, or template1

Ruby on Rails took this concept one step further by providing a program that 
would
automatically generate scaffolding for you1 The advantage of this approach is 
that it
could generate a more sophisticated framework than just selecting from a 
collection of
templates1

Express has taken a page from Ruby on Rails and provided a utility to generate 
scaf‐
folding to start your Express project1

While the Express scaffolding utility is useful, it currently doesn1t generate 
the frame‐
work I will be recommending in this book1 In particular, it doesn1t provide 
support for
my templating language of choice (Handlebars), and it also doesn1t follow some 
of the
naming conventions I prefer (though that is easy enough to fix)1

While we won1t be using the scaffolding utility, I encourage you to take a look 
at it once
you1ve finished the book: by then you1ll be armed with everything you need to 
know to
evaluate whether the scaffolding it generates is useful for you1

Boilerplate is also useful for the actual HTML that will be delivered to the 
client1 I
recommend the excellent HTML5 Boilerplate1 It generates a great blank slate for 
an

19


HTML5 website1 Recently, HTML5 Boilerplate has added the ability to generate a 
cus‐
tom build1 One of the custom build options includes Twitter Bootstrap, a 
frontend
framework I highly recommend1 We1ll be using a Bootstrap-based custom build in
Chapter    7 to provide a responsive, modern HTML5 website1

The Meadowlark Travel Website

Throughout  this  book,  we1ll  be  using  a  running  example:  a  fictional  
website  for
Meadowlark Travel, a company offering services for people visiting the great 
state of
Oregon1 If you1re more interested in creating a REST application, have no fear: 
the
Meadowlark Travel website will expose REST services in addition to serving a 
functional
website1

Initial Steps

Start by creating a new directory for your project: this will be the root 
directory for your
project1 In this book, whenever we refer to the “project directory,” “app 
directory,” or
“project root,” we1re referring to this directory1

You1ll probably want to keep your web app files separate from all the
other files that usually accompany a project, such as meeting notes,
documentation,  etc1  For  that  reason,  I  recommend  making  your
project           root a subdirectory of your project directory1 For example, 
for
the Meadowlark Travel website, I might keep the project in ~/projects/
meadowlark, and the project root in ~/projects/meadowlark/site1

npm manages project dependencies—as well as metadata about the project—in a file
called package1json1 The easiest way to create this file is to run npm init: it 
will ask you
a series of questions and generate a package1json file to get you started (for 
the “entry
point” question, use meadowlark1js or the name of your project)1

Every time you run npm, you1ll get warnings unless you provide a
repository URL in package1json, and a nonempty README1md file1
The metadata in the package1json file is really only necessary if you1re
planning on publishing to the npm repository, but squelching npm
warnings is worth the small effort1

The first step will be installing Express1 Run the following npm command:

npm install --save express

Running npm install will install the named package(s) in the node_modules 
directo‐
ry1  If  you  specify  the  --save flag,  it  will  update  the  package1json  
file1  Since  the


node_modules dirctory can be regenerated at any time with npm, we will not save 
it in
our repository1 To ensure we don1t accidentally add it to our repository, we 
create a file
called 1gitignore:

# ignore packages installed by npm
node_modules

# put any other files you don't want to check in here,
# such as 1DS_Store (OSX), *1bak, etc1

Now create a file called meadowlark1js1 This will be our project1s entry point1 
Throughout
the book, we will simply be referring to this file as the “app file”:

var express = require('express');

var app = express();

app1set('port', process1env1PORT || 3000);

// custom 404 page

app1use(function(req, res){
res1type('text/plain');
res1status(404);
res1send('404 - Not Found');

});

// custom 500 page

app1use(function(err, req, res, next){
console1error(err1stack);
res1type('text/plain');
res1status(500);

res1send('500 - Server Error');

});

app1listen(app1get('port'), function(){

console1log( 'Express started on http://localhost:' +
app1get('port') + '; press Ctrl-C to terminate1' );

});

Many tutorials, as well as the Express scaffolding generator, encour‐
age you to name your primary file app1js (or sometimes index1js or
server1js)1 Unless you1re using a hosting service or deployment sys‐
tem   that requires your main application file to have a specific name,
I don1t feel there1s a compelling reason to do this, and I prefer to name
the primary file after the project1 Anyone who1s ever stared at a bunch
of editor tabs that all say “index1html” will immediately see the wis‐
dom of this1 npm init will default to index1js; if you use a different
name for your application file, make sure to update the main proper‐
ty   in package1json1


You  now  have  a  minimal  Express  server1  You  can  start  the  server  
(node meadow
lark1js), and navigate to http://localhost:30001 The result will be 
disappointing: you
haven1t provided Express with any routes, so it will simply give you a generic 
404 page
indicating that the page doesn1t exist1

Note how we specify the port that we want our application to run on:
app1set(port,  process1env1PORT  ||  3000)1  This  allows  us  to
override the port by setting an environment value before you start the
server1  If  your  app  isn1t  running  on  port  3000  when  you  run  this
example, check to see if your PORT environment variable is set1

I  highly  recommend  getting  a  browser  plugin  that  shows  you  the
status code of the HTTP request as well as any redirects that took
place1 It will make it easier to spot redirect issues in your code, or
incorrect status codes, which are often overlooked1 For Chrome, Ayi‐
ma1s Redirect Path works wonderfully1 In most browsers, you can see
the status code in the Network section of the developer tools1

Let1s add some routes for the home page and an About page1 Before the 404 
handler,
we1ll add two new routes:

app1get('/', function(req, res){
res1type('text/plain');
res1send('Meadowlark Travel');

});

app1get('/about', function(req, res){
res1type('text/plain');
res1send('About Meadowlark Travel');

});

// custom 404 page

app1use(function(req, res, next){
res1type('text/plain');
res1status(404);
res1send('404 - Not Found');

});

app1get is the method by which we1re adding routes1 In the Express 
documentation,
you will see app1VERB1 This doesn1t mean that there1s literally a method called 
VERB; it1s
just a placeholder for your (lowercased) HTTP verbs (“get” and “post” being the 
most
common)1 This method takes two parameters: a path and a function1

The path is what defines the route1 Note that app1VERB does the heavy lifting 
for you:
by default, it doesn1t care about the case or trailing slash, and it doesn1t 
consider the
querystring when performing the match1 So the route for the About page will work
for    /about, /About, /about/, /about?foo=bar, /about/?foo=bar, etc1


The function you provide will get invoked when the route is matched1 The 
parameters
passed to that function are the request and response objects, which we1ll learn 
more
about in Chapter 61 For now, we1re just returning plaintext with a status code 
of 200
(Express defaults to a status code of 200—you don1t have to specify it 
explicitly)1

Instead of using Node1s low-level res1end, we1re switching to using Express1s 
extension,
res1send1 We are also replacing Node1s res1writeHead with res1set and res1sta
tus1 Express is also providing us a convenience method, res1type, which sets the
Content-Type header1 While it1s still possible to use res1writeHead and 
res1end, it isn1t
necessary    or recommended1

Note that our custom 404 and 500 pages must be handled slightly differently1 
Instead
of using app1get, it is using app1use1 app1use is the method by which Express 
adds
middleware1 We1ll be covering middleware in more depth in Chapter 10, but for 
now,
you        can think of this as a catch-all handler for anything that didn1t 
get matched by a
route1 This brings us to a very important point: in Express, the order in which 
routes and
middleware are added is significant1 If we put the 404 handler above the 
routes, the home
page     and About page would stop working: instead, those URLs would result in 
a 4041
Right now, our routes are pretty simple, but they also support wildcards, which 
can lead
to problems with ordering1 For example, what if we wanted to add subpages to 
About,
such as /about/contact and /about/directions? The following will not work as 
expected:

app1get('/about*',function(req,res){

// send content1111

})

app1get('/about/contact',function(req,res){

// send content1111

})

app1get('/about/directions',function(req,res){

// send content1111

})

In this example, the /about/contact and /about/directions handlers will never be
matched because the first handler uses a wildcard in its path: /about*1

Express can distinguish between the 404 and 500 handlers by the number of 
arguments
their callback functions take1 Error routes will be covered in depth in 
Chapters 10 and 121

Now you can start the server again, and see that there1s a functioning home 
page and
About page1

So far, we haven1t done anything that couldn1t be done just as easily without 
Express,
but already Express is providing us some functionality that isn1t immediately 
obvious1
Remember in the previous chapter how we had to normalize req1url to determine 
what
resource was being requested? We had to manually strip off the querystring and 
the
trailing slash, and convert to lowercase1 Express1s router is now handling 
those details


for us automatically1 While it may not seem like a large thing now, it1s only 
scratching
the surface of what Express1s router is capable of1

Views and Layouts

If you1re familiar with the “model-view-controller” paradigm, then the concept 
of a view
will be no stranger to you1 Essentially, a view is what gets delivered to the 
user1 In the
case of a website, that usually means HTML, though you could also deliver a PNG 
or a
PDF, or anything that can be rendered by the client1 For our purposes, we will 
consider
views to be HTML1

Where a view differs from a static resource (like an image or CSS file) is that 
a view
doesn1t necessarily have to be static: the HTML can be constructed on the fly 
to provide
a customized page for each request1

Express supports many different view engines that provide different levels of 
abstrac‐
tion1 Express gives some preference to a view engine called Jade (which is no 
surprise,
because it is also the brainchild of TJ Holowaychuk)1 The approach Jade takes 
is very
minimal: what you write doesn1t resemble HTML at all, which certainly 
represents a lot
less typing: no more angle brackets or closing tags1 The Jade engine then takes 
that and
converts it to HTML1

Jade is very appealing, but that level of abstraction comes at a cost1 If 
you1re a frontend
developer, you have to understand HTML and understand it well, even if you1re 
actually
writing your views in Jade1 Most frontend developers I know are uncomfortable 
with
the idea of their primary markup language being abstracted away1 For this 
reason, I am
recommending the use of another, less abstract templating framework called 
Handle‐
bars1 Handlebars (which is based on the popular language-independent templating
language Mustache) doesn1t attempt to abstract away HTML for you: you write HTML
with special tags that allow Handlebars to inject content1

To  provide  Handlebars  support,  we1ll  use  Eric  Ferraiuolo1s  
express3-handlebars
package (despite the name, this package works fine with Express 410)1 In your 
project
directory, execute:

npm install --save express3-handlebars

Then in meadowlark1js, add the following lines after the app has been created:

var app = express();

// set up handlebars view engine

var handlebars = require('express3-handlebars')

1create({ defaultLayout:'main' });
app1engine('handlebars', handlebars1engine);
app1set('view   engine', 'handlebars');


This creates a view engine and configures Express to use it by default1 Now 
create a
directory called views that has a subdirectory called layouts1 If you1re an 
experienced
web developer, you1re probably already comfortable with the concepts of layouts 
(some‐
times called “master pages”)1 When you build a website, there1s a certain 
amount of
HTML that1s the same—or very close to the same—on every page1 Not only does it
become tedious to rewrite all that repetitive code for every page, it creates a 
potential
maintenance nightmare: if you want to change something on every page, you have 
to
change all the files1 Layouts free you from this, providing a common framework 
for all
the pages on your site1

So let1s create a template for our site1 Create a file called 
views/layouts/main1handlebars:

<!doctype html>

<html>

<head>

<title>Meadowlark Travel</title>

</head>

<body>

{{{body}}}

</body>

</html>

The only thing that you probably haven1t seen before is this: {{{body}}}1 This 
expression
will be replaced with the HTML for each view1 When we created the Handlebars in‐
stance, note we specified the default layout (defaultLayout:'main')1 That means 
that
unless you specify otherwise, this is the layout that will be used for any 
view1

Now let1s create view pages for our home page, views/home1handlebars:

<h1>Welcome to Meadowlark Travel</h1>

Then our About page, views/about1handlebars:

<h1>About Meadowlark Travel</h1>

Then our Not Found page, views/4041handlebars:

<h1>404 - Not Found</h1>

And finally our Server Error page, views/5001handlebars:

<h1>500 - Server Error</h1>

You probably want your editor to associate 1handlebars and 1hbs (an‐
other common extension for Handlebars files) with HTML, to enable
syntax highlighting and other editor features1 For vim, you can add
the   line   au  BufNewFile,BufRead  *1handlebars  set  file
type=html to  your  ~/1vimrc  file1  For  other  editors,  consult  your
documentation1


Now that we1ve got some views set up, we have to replace our old routes with 
new routes
that use these views:

app1get('/', function(req, res) {
res1render('home');

});

app1get('/about', function(req, res) {
res1render('about');

});

// 404 catch-all handler (middleware)

app1use(function(req, res, next){
res1status(404);
res1render('404');

});

// 500 error handler (middleware)

app1use(function(err, req, res, next){
console1error(err1stack);
res1status(500);
res1render('500');

});

Note that we no longer have to specify the content type or status code: the 
view engine
will return a content type of text/html and a status code of 200 by default1 In 
the catch-
all handler, which provides our custom 404 page, and the 500 handler, we have 
to set
the status code explicitly1

If you start your server and check out the home or About page, you1ll see that 
the views
have been rendered1 If you examine the source, you1ll see that the boilerplate 
HTML
from views/layouts/main1handlebars is there1

Static Files and Views

Express relies on a middleware to handle static files and views1 Middleware is 
a concept
that will be covered in more detail in Chapter 101 For now, it1s sufficient to 
know that
middleware provides modularization, making it easier to handle requests1

The static middleware allows you to designate one or more directories as 
containing
static resources that are simply to be delivered to the client without any 
special handling1
This is where you would put things like images, CSS files, and client-side 
JavaScript files1

In your project directory, create a subdirectory called public (we call it 
public because
anything in this directory will be served to the client without question)1 
Then, before
you declare any routes, you1ll add the static middleware:

app1use(express1static(  dirname + '/public'));


The static middleware has the same effect as creating a route for each static 
file you
want to deliver that renders a file and returns it to the client1 So let1s 
create an img
subdirectory inside public, and put our logo1png file in there1

Now we can simply reference /img/logo1png (note, we do not specify public; that 
di‐
rectory is invisible to the client), and the static middleware will serve that 
file, setting
the content type appropriately1 Now let1s modify our layout so that our logo 
appears on
every page:

<body>

<header><img src="/img/logo1png" alt="Meadowlark Travel Logo"></header>

{{{body}}}

</body>

The <header> element was introduced in HTML5 to provide addi‐
tional semantic information about content that appears at the top of
the page, such as logos, title text, or navigation1

Dynamic Content in Views

Views aren1t simply a complicated way to deliver static HTML (though they can 
certainly
do that as well)1 The real power of views is that they can contain dynamic 
information1

Let1s say that on the About page, we want to deliver a “virtual fortune 
cookie1” In our

meadowlark1js file, we define an array of fortune cookies:

var fortunes = [

"Conquer your fears or they will conquer you1",
"Rivers need springs1",

"Do not fear what you don't know1",
"You will have a pleasant surprise1",
"Whenever possible, keep it simple1",

];

Modify the view (/views/about1handlebars) to display a fortune:

<h1>About Meadowlark Travel</h1>

<p>Your fortune for the day:</p>

<blockquote>{{fortune}}</blockquote>

Now modify the route /about to deliver the random fortune cookie:

app1get('/about', function(req, res){

var randomFortune =

fortunes[Math1floor(Math1random() * fortunes1length)];
res1render('about', { fortune: randomFortune });

});


Now if you restart the server and load the /about page, you1ll see a random 
fortune1
Templating is incredibly useful, and we will be covering it in depth in Chapter 
71

Conclusion

We1ve created a very basic website with Express1 Even though it1s simple, it 
contains all
the seeds we need for a full-featured website1 In the next chapter, we1ll be 
crossing our
ts and dotting our is in preparation for adding more advanced functionality1


CHAPTER 4

Tidying Up

In the last two chapters, we were just experimenting: dipping our toes into the 
waters,
so to speak1 Before we proceed to more complex functionality, we1re going to do 
some
housekeeping and build some good habits into our work1

In this chapter, we1ll start our Meadowlark Travel project in earnest1 Before 
we start
building the website itself, though, we1re going to make sure we have the tools 
we need
to produce a high-quality product1

The running example in this book is not necessarily one you have to
follow1 If you1re anxious to build your own website, you could follow
the framework of the running example, but modify it accordingly so
that  by  the  time  you  finish  this  book,  you  could  have  a  finished
website!

Best Practices

The phrase “best practices” is one you hear thrown around a lot these days, and 
it means
that you should “do things right” and not cut corners (we1ll talk about what 
this means
specifically in a moment)1 No doubt you1ve heard the engineering adage that 
your op‐
tions     are “fast,” “cheap,” and “good,” and you can pick any two1 The thing 
that1s always
bothered me about this model is that it doesn1t take into account the accrual 
value of
doing things correctly1 The first time you do something correctly, it may take 
five times
as long to do it as it would have to do it quick and dirty1 The second time, 
though, it1s
only going to take three times as long1 By the time you1ve done it correctly a 
dozen times,
you1ll be doing it almost as fast as the quick and dirty way1

I had a fencing coach who would always remind us that practice doesn1t make 
perfect:
practice makes permanent1 That is, if you do something over and over again, 
eventually
it      will become automatic, rote1 That is true, but it says nothing about 
the quality of the


thing you are practicing1 If you practice bad habits, then bad habits become 
rote1 Instead,
you should follow the rule that perfect practice makes perfect1 In that spirit, 
I encourage
you to follow the rest of the examples in this book as if you were making a 
real-live
website, as if your reputation and remuneration were depending on the quality 
of the
outcome1 Use this book to not only learn new skills, but to practice building 
good habits1

The practices we will be focusing on are version control and QA1 In this 
chapter, we1ll
be discussing version control, and we1ll discuss QA in the next chapter1

Version Control

Hopefully I don1t have to convince you of the value of version control (if I 
did, that might
take a whole book itself)1 Broadly speaking, version control offers these 
benefits:

Documentation

Being able to go back through the history of a project to see the decisions 
that were
made and the order in which components were developed can be valuable docu‐
mentation1 Having a technical history of your project can be quite useful1

Attribution

If you work on a team, attribution can be hugely important1 Whenever you find
something in code that is opaque or questionable, knowing who made that change
can save you many hours1 It could be that the comments associated with the 
change
are sufficient to answer your questions, and if not, you1ll know who to talk 
to1

Experimentation

A good version control system enables experimentation1 You can go off on a 
tangent,
trying something new, without fear of affecting the stability of your project1 
If the
experiment is successful, you can fold it back into the project, and if it is 
not suc‐
cessful, you can abandon it1

Years ago, I made the switch to distributed version control systems (DVCS)1 I 
narrowed
my choices down to Git and Mercurial, and went with Git, due to its ubiquity and
flexibility1 Both are excellent and free version control systems, and I 
recommend you
use     one of them1 In this book, we will be using Git, but you are welcome to 
substitute
Mercurial (or another version control system altogether)1

If you are unfamiliar with Git, I recommend Jon Loeliger1s excellent Version 
Control
with Git (O1Reilly)1 Also, Code School has a nice introductory course on Git1

How to Use Git with This Book

First, make sure you have Git1 Type git --version1 If it doesn1t respond with a 
version
number,  you1ll  need  to  install  Git1  See  the  Git  documentation  for  
installation
instructions1


There are two ways to follow along with the examples in this book1 One is to 
type out
the examples yourself, and follow along with the Git commands1 The other is to 
clone
the Git repository I am using for all of the examples and check out the 
associated tags
for each example1 Some people learn better by typing out examples, while some 
prefer
to just see and run the changes without having to type it all in1

If You1re Following Along by Doing It Yourself

We1ve already got a very rough framework for our project: some views, a layout, 
a logo,
a main application file, and a package1json file1 Let1s go ahead and create a 
Git repository
and add all those files1

First, we go to the project directory and create a Git repository there:

git init

Now before we add all the files, we1ll create a 1gitignore file to help prevent 
us from
accidentally adding things we don1t want to add1 Create a text file called 
1gitignore in
your project directory in which you can add any files or directories you want 
Git to
ignore by default (one per line)1 It also supports wildcards1 For example, if 
your editor
creates backup files with a tilde at the end (like meadowlark1js~), you might 
put *~ in
the 1gitignore file1 If you1re on a Mac, you1ll want to put 1DS_Store in there1 
You1ll also
want to put node_modules in there (for reasons that will be discussed soon)1 So 
for now,
the file might look like this:

node_modules

*~

1DS_Store

Entries in the 1gitignore file also apply to subdirectories1 So if you put

*~ in the 1gitignore in the project root, all such backup files will be
ignored even if they are in subdirectories1

Now we can add all of our existing files1 There are many ways to do this in 
Git1 I generally
favor git add -A, which is the most sweeping of all the variants1 If you are 
new to Git,
I recommend you either add files one by one (git add meadowlark1js, for example)
if you only want to commit one or two files, or git add -A if you want to add 
all of
your changes (including any files you might have deleted)1 Since we want to add 
all the
work we1ve already done, we1ll use:

git add -A


Newcomers to Git are commonly confused by the git add command:
it adds changes, not files1 So if you1ve modified meadowlark1js, and
then you type git add meadowlark1js, what you1re really doing is
adding the changes you1ve made1

Git has a “staging area,” where changes go when you run git add1 So the changes 
we1ve
added haven1t actually been committed yet, but they1re ready to go1 To commit 
the
changes, use git commit:

git commit -m "Initial commit1"

The -m "Initial commit1" allows you to write a message associated with this 
commit1
Git won1t even let you make a commit without a message, and for good reason1 
Always
strive to make meaningful commit messages: they should briefly but concisely 
describe
the work you1ve done1

If You1re Following Along by Using the Official Repository

For the official repository, I create a tag every time we add to or modify the 
existing
source code1 To get started with it, simply clone it:

git clone https://github1com/EthanRBrown/web-development-with-node-and-express

For convenience, I1ve added a tag for the beginning of each chapter (which 
usually points
to the last commit of the previous chapter)1 So now you can just check out the 
tag
associated with this chapter:

git checkout ch04

Note that chapter tags (like ch04) represent the state of the project as you1re 
going into
that chapter, before we1ve covered anything, and may sometimes be concomitant 
with
the last tag in the previous chapter1 As the chapter progresses, tags will be 
added after
the content is discussed1 For example, once you read the upcoming “npm Packages”
section, you can check out the tag ch04-npm-packages to see the changes 
discussed in
that section1 Not every section has a corresponding tag, but I1ve tried to make 
the
repository as easy to follow as possible1 See the README file for more 
information
about how the repository is structured1


If at any point you want to experiment, keep in mind that the tag you
have checked out puts you in what Git calls a “detached HEAD” state1
While you are free to edit any files, it is unsafe to commit anything
you do without creating a branch first1 So if you do want to base an
experimental branch off of a tag, simply create a new branch and
check            it out, which you can do with one command: git checkout -b
experiment (where experiment is the name of your branch; you can
use whatever you want)1 Then you can safely edit and commit on that
branch as much as you want1

npm Packages

The npm packages that your project relies on reside in a directory called 
node_mod‐
ules (it1s unfortunate that this is called node_modules and not npm_packages, 
as Node
modules are a related but different concept)1 Feel free to explore that 
directory to satisfy
your curiosity or to debug your program, but you should never modify any code 
in this
directory1 In addition to that being bad practice, all of your changes could 
easily be
undone by npm1 If you need to make a modification to a package your project 
depends
on,   the correct course of action would be to create your own fork of the 
project1 If you
do go this route, and you feel that your improvements would be useful to 
others, con‐
gratulations: you1re now involved in an open source project! You can submit your
changes, and if they meet the project standards, they1ll be included in the 
official pack‐
age1 Contributing to existing packages and creating customized builds is beyond 
the
scope of this book, but there is a vibrant community of developers out there to 
help you
if you want to contribute to existing packages1

The purpose of the package1json file is twofold: to describe your project and 
to list
dependencies1 Go ahead and look at your package1json file now1 You should see 
this:

{

"dependencies": {

"express": "^41010",

"express3-handlebars": "^01510"

}

}

Right now, our package1json file contains only information about dependencies1 
The
caret (^) in front of the package versions indicates that any version that 
starts with the
specified version number—up to the next major version number—will work1 For ex‐
ample, this package1json indicates that any version of Express that starts with 
41010 will
work, so 41011 and 41919 would both work, but 31417 would not, nor would 510101 
This is
the default version specificity when you use npm install --save, and is 
generally a
pretty safe bet1 The consequence of this approach is that if you want to move 
up to a
newer version, you will have to edit the file to specify the new version1 
Generally, that1s
a good thing because it prevents changes in dependencies from breaking your 
project


without your knowing about it1 Version numbers in npm are parsed by a component
called “semver” (for “semantic versioner”)1 If you want more information about 
ver‐
sioning in npm, consult the semver documentation1

Since the package1json file lists all the dependencies, the node_modules 
directory is really
a derived artifact1 That is, if you were to delete it, all you would have to do 
to get the
project working again would be to run npm install, which will recreate the 
directory
and put all the necessary dependencies in it1 It is for this reason that I 
recommend
putting node_modules in your 1gitignore file, and not including it in source 
control1
However, some people feel that your repository should contain everything 
necessary to
run    the project, and prefer to keep node_modules in source control1 I find 
that this is
“noise” in the repository, and I prefer to omit it1

Whenever you use a Node module in your project, you should make sure it1s 
listed as a
dependency in package1json1 If you fail to do this, npm will be unable to 
construct the
right dependencies, and when another developer checks out the project (or when 
you
do on a different computer), the correct dependencies won1t be installed, which 
negates
the value of a package manager1

Project Metadata

The other purpose of the package1json file is to store project metadata, such 
as the name
of the project, authors, license information, and so on1 If you use npm init to 
initially
create your package1json file, it will populate the file with the necessary 
fields for you,
and you can update them at any time1 If you intend to make your project 
available on
npm or GitHub, this metadata becomes critical1 If you would like more 
information
about the fields in package1json, see the package1json documentation1 The other 
impor‐
tant piece of metadata is the README1md file1 This file can be a handy place to 
describe
the overall architecture of the website, as well as any critical information 
that someone
new to the project might need1 It is in a text-based wiki format called 
Markdown1 Refer
to the Markdown documentation for more information1

Node Modules

As mentioned earlier, Node modules and npm packages are related but different 
con‐
cepts1 Node modules, as the name implies, offer a mechanism for modularization 
and
encapsulation1 npm packages provide a standardized scheme for storing, 
versioning,
and referencing projects (which are not restricted to modules)1 For example, we 
import
Express itself as a module in our main application file:

var express = require('express');

require is a Node function for importing a module1 By default, Node looks for 
modules
in the directory node_modules (it should be no surprise, then, that there1s an 
express


directory inside of node_modules)1 However, Node also provides a mechanism for
creating  your  own  modules  (you  should  never  create  your  own  modules  
in  the
node_modules directory)1 Let1s see how we can modularize the fortune cookie 
func‐
tionality      we implemented in the previous chapter1

First let1s create a directory to store our modules1 You can call it whatever 
you want, but

lib (short for “library”) is a common choice1 In that folder, create a file 
called fortune1js:

var fortuneCookies = [

"Conquer your fears or they will conquer you1",
"Rivers need springs1",

"Do not fear what you don't know1",
"You will have a pleasant surprise1",
"Whenever possible, keep it simple1",

];

exports1getFortune = function() {

var idx = Math1floor(Math1random() * fortuneCookies1length);

return fortuneCookies[idx];

};

The important thing to note here is the use of the global variable exports1 If 
you want
something to be visible outside of the module, you have to add it to exports1 
In this
example, the function getFortune will be available from outside this module, 
but our
array fortuneCookies will be completely hidden1 This is a good thing: 
encapsulation
allows for less error-prone and fragile code1

There are several ways to export functionality from a module1 We will
be covering different methods throughout the book and summariz‐
ing them in Chapter 221

Now in meadowlark1js, we can remove the fortuneCookies array (though there would
be no harm in leaving it: it can1t conflict in any way with the array with the 
same name
defined in lib/fortune1js)1 It is traditional (but not required) to specify 
imports at the top
of    the file, so at the top of the meadowlark1js file, add the following 
line:

var fortune = require('1/lib/fortune1js');

Note that we prefix our module name with 1/1 This signals to Node that it 
should not
look for the module in the node_modules directory; if we omitted that prefix, 
this would
fail1


Now in our route for the About page, we can utilize the getFortune method from 
our
module:

app1get('/about', function(req, res) {

res1render('about', { fortune: fortune1getFortune() } );

});

If you1re following along, let1s commit those changes:

git add -A

git commit -m "Moved 'fortune cookie' functionality into module1"

Or if you1re using the official repository, you can see the changes in this 
tag:

git checkout ch04

You will find modules to be a very powerful and easy way to encapsulate 
functionality,
which will improve the overall design and maintainability of your project, as 
well as
make  testing  easier1  Refer  to  the  official  Node  module  documentaion  
for  more
information1


CHAPTER 5

Quality Assurance

Quality assurance: it1s a phrase that is prone to send shivers down the spines 
of devel‐
opers—which is unfortunate1 After all, don1t you want to make quality software? 
Of
course you do1 So it1s not the end goal that1s the sticking point: it1s the 
politics of the
matter1 I1ve found that there are two common situations that arise in web 
development:

Large or well-funded organizations

There1s usually a QA department and, unfortunately, an adversarial relationship
springs up between QA and development1 This is the worst thing that can happen1
Both departments are playing on the same team, for the same goal, but QA often
defines success as finding more bugs, while development defines success as 
gener‐
ating fewer bugs, and that serves as the basis for conflict and competition1

Small organizations and organizations on a budget

Often, there is no QA department; the development staff is expected to serve the
dual role of establishing QA and developing software1 This is not a ridiculous 
stretch
of the imagination or a conflict of interest1 However, QA is a very different 
discipline
than development, and it attracts different personalities and talents1 This is 
not an
impossible situation, and certainly there are developers out there who have the 
QA
mindset, but when deadlines loom, it1s usually QA that gets the short shrift, 
to the
project1s detriment1

With  most  real-world  endeavors,  multiple  skills  are  required,  and  
increasingly,  it1s
harder to be an expert in all of those skills1 However, some competency in the 
areas for
which you are not directly responsible will make you more valuable to the team 
and
make the team function more effectively1 A developer acquiring QA skills offers 
a great
example: these two disciplines are so tightly intertwined that 
cross-disciplinary under‐
standing is extremely valuable1

There is also a movement to merge the roles of QA and development, making 
developers
responsible for QA1 In this paradigm, software engineers who specialize in QA 
act


almost as consultants to developers, helping them build QA into their 
development
workflow1 Whether QA roles are divided or integrated, it is clear that 
understanding
QA         is beneficial to developers1

This book is not for QA professionals; it is aimed at developers1 So my goal is 
not to
make you a QA expert, but to give you some experience in that area1 If your 
organization
has a dedicated QA staff, it will make it easier for you to communicate and 
collaborate
with them1 If you do not, it will give you a starting point to establishing a 
comprehensive
QA plan for your project1

QA: Is It Worth It?

QA can be expensive—sometimes very expensive1 So is it worth it? It1s a 
complicated
formula with complicated inputs1 Most organizations operate on some kind of 
“return
on investment” model1 If you spend money, you must expect to receive at least 
as much
money in return (preferably more)1 With QA, though, the relationship can be 
muddy1
A well-established and well-regarded product, for example, may be able to get 
by with
quality issues for longer than a new and unknown project1 Obviously, no one 
wants to
produce a low-quality product, but the pressures in technology are high1 
Time-to-
market can be critical, and sometimes it1s better to come to market with 
something that1s
less than perfect than to come to market with the perfect product two months 
later1

In web development, quality can be broken down into three dimensions:

Reach

Reach refers to the market penetration of your product: the number of people
viewing your website or using your service1 There1s a direct correlation between
reach and profitability: the more people who visit the website, the more people 
who
buy the product or service1 From a development perspective, search engine opti‐
mization (SEO) will have the biggest impact on reach, which is why we will be
including SEO in our QA plan1

Functionality

Once people are visiting your site or using your service, the quality of your 
site1s
functionality  will  have  a  large  impact  on  user  retention:  a  site  
that  works  as
advertised is more likely to drive return visits than one that isn1t1 Unlike 
the other
dimensions, functionality testing can often be automated1

Usability

Where functionality is concerned with functional correctness, usability 
evaluates
human-computer  interaction  (HCI)1  The  fundamental  question  is,  “Is  the
functionality delivered in a way that is useful to the target audience?” This 
often
translates to, “Is it easy to use?” though the pursuit of ease can often oppose 
flexi‐
bility or power: what seems easy to a programmer might be different than what
seems easy to a nontechnical consumer1 In other words, you must consider your


target audience when assessing usability1 Since a fundamental input to a 
usability
measurement is a user, usability is not usually something that can be automated1
However, user testing should be included in your QA plan1

Aesthetics

Aesthetics is the most subjective of the three dimensions and is therefore the 
least
relevant to development1 While there are few development concerns when it comes
to  your site1s aesthetics, routine reviews of your site1s aesthetics should be 
part of
your QA plan1 Show your site to a representative sample audience, and find out 
if
it feels dated or does not invoke the desired response1 Keep in mind that 
aesthetics
is time sensitive (aesthetic standards shift over time) and audience specific 
(what
appeals to one audience may be completely uninteresting to another)1

While all four dimensions should be addressed in your QA plan, functionality 
testing
and SEO can be tested automatically during development, so that will be the 
focus of
this chapter1

Logic Versus Presentation

Broadly speaking, in your website, there are two “realms”: logic (often called 
“business
logic,” a term I eschew because of its bias toward commercial endeavor) and 
presenta‐
tion1 You can think of your website1s logic existing in kind of a pure 
intellectual domain1
For example, in our Meadowlark Travel scenario, there might be a rule that a 
customer
must possess a valid driver1s license before renting a scooter1 This is a very 
simple data-
based rule: for every scooter reservation, the user needs a valid driver1s 
license1 The
presentation of this is disconnected1 Perhaps it1s just a checkbox on the final 
form of the
order page, or perhaps the customer has to provide a valid driver1s license 
number, which
is validated by Meadowlark Travel1 It1s an important distinction, because 
things should
be as clear and simple as possible in the logic domain, whereas the 
presentation can be
as complicated or as simple as it needs to be1 The presentation is also subject 
to usability
and aesthetic concerns, where the business domain is not1

Whenever possible, you should seek a clear delineation between your logic and 
pre‐
sentation1 There are many ways to do that, and in this book, we will be 
focusing on
encapsulating logic in JavaScript modules1 Presentation, on the other hand, 
will be a
combination of HTML, CSS, multimedia, JavaScript, and frontend libraries like 
jQuery1

The Types of Tests

The type of testing we will be considering in this book falls into two broad 
categories:
unit testing and integration testing (I am considering “system testing” to be a 
type of
integration testing)1 Unit testing is very fine-grained, testing single 
components to make
sure    they function properly, whereas integration testing tests the 
interaction between
multiple components, or even the whole system1

Logic Versus Presentation    |    39


In general, unit testing is more useful and appropriate for logic testing 
(although we
will see some instances where it is used in presentation code as well)1 
Integration testing
is useful in both realms1

Overview of QA Techniques

In this book, we will be using the following techniques and software to 
accomplish
thorough testing:

Page testing

“Page testing,” as the name implies, tests the presentation and frontend 
functionality
of a page1 This can involve both unit and integration testing1 We will be using 
Mocha
to achieve this1

Cross-page testing

Cross-page testing involves testing functionality that requires navigation from 
one
page to another1 For example, the checkout process in an ecommerce site usually
spans multiple pages1 Since this kind of testing inherently involves more than 
one
component, it is generally considered integration testing1 We will be using Zom‐
bie1js        for this1

Logic testing

Logic testing will execute unit and integration tests against our logic domain1 
It will
be testing only JavaScript, disconnected from any presentation functionality1

Linting

Linting isn1t about finding errors, but potential errors1 The general concept 
of linting
is that it identifies areas that could represent possible errors, or fragile 
constructs
that could lead to errors in the future1 We will be using JSHint for linting1

Link checking

Link checking (making sure there are no broken links on your site) falls into 
the
category of “low-hanging fruit1” It may seem overkill on a simple project, but 
simple
projects have a way of becoming complicated projects, and broken links will 
happen1
Better to work link checking into your QA routine early1 Link checking falls 
under
the category of unit testing (a link is either valid or invalid)1 We will be 
using Link‐
Checker for this1

Running Your Server

All of the techniques in this chapter assume your website is running1 So far, 
we1ve been
running our website manually, with the command node meadowlark1js1 This techni‐
que  has the advantage of simplicity, and I usually have a dedicated window on 
the
desktop for that purpose1 That1s not your only option, however1 If you find 
yourself
forgetting to restart your website when you make JavaScript changes, you might 
want


to look into a monitor utility that will automatically restart your server when 
it detects
changes in JavaScript1 nodemon is very popular, and there1s also a Grunt 
plugin1 You
will     be learning more about Grunt at the end of this chapter1 For now, I 
recommend just
having your app always running in a different window1

Page Testing

My recommendation for page testing is that you actually embed tests in the page 
it‐
self1 The advantage of this is that while you1re working on a page, you can 
immediately
spot any errors as you load it in a browser1 Doing this will require a little 
setup, so let1s
get started1

The first thing we1ll need is a test framework1 We1ll be using Mocha1 First, we 
add the
package to the project:

npm install --save-dev mocha

Note that we used --save-dev instead of --save; this tells npm to list this 
package in
the development dependencies instead of the runtime dependencies1 This will 
reduce
the number of dependencies the project has when we deploy live instances of the 
website1

Since we1ll be running Mocha in the browser, we need to put the Mocha resources 
in
the public folder so it will be served to the client1 We1ll put these in a 
subdirectory, public/
vendor:

mkdir public/vendor

cp node_modules/mocha/mocha1js public/vendor
cp node_modules/mocha/mocha1css public/vendor

It1s a good idea to put third-party libraries that you are using in a
special directory, like vendor1 This makes it easier to separate what
code  you1re  responsible  for  testing  and  modifying,  and  what  code
should be hands off1

Tests usually require a function called assert (or expect)1 This is available 
in the Node
framework, but not inherently in a browser, so we1ll be using the Chai 
assertion library:

npm install --save-dev chai

cp node_modules/chai/chai1js public/vendor

Now that we have the necessary files, we can modify the Meadowlark Travel 
website to
allow running tests1 The catch is, we don1t want the tests to always be there: 
not only
will it slow down your website, but your users don1t want to see the results of 
tests! Tests
should be disabled by default, but it should be very easy to enable them1 To 
meet both
of these goals, we1re going to use a URL parameter to turn on tests1 When we1re 
done,


going  to  http://localhost:3000  will  load  the  home  page,  and  
http://localhost:3000?
test=1 will load the home page complete with tests1

First, we1re going to use some middleware to detect test=1 in the querystring1 
It must
appear before we define any routes in which we wish to use it:

app1use(function(req, res, next){

res1locals1showTests = app1get('env') !== 'production' &&
req1query1test === '1';

next();

});

// routes go here1111

The specifics about this bit of code will become clear in later chapters; what 
you need
to know for right now is that if test=1 appears in the querystring for any page 
(and
we1re not running on a production server), the property res1locals1showTests 
will
set to be true1 The res1locals object is part of the context that will be 
passed to views
(this will be explained in more detail in Chapter 7)1

Now we can modify views/layouts/main1handlebars to conditionally include the 
test
framework1 Modify the <head> section:

<head>

<title>Meadowlark Travel</title>

{{#if showTests}}

<link rel="stylesheet" href="/vendor/mocha1css">

{{/if}}

<script src="//code1jquery1com/jquery-210121min1js"></script>

</head>

We1re linking in jQuery here because, in addition to using it as our primary DOM
manipulation library for the site, we can use it to make test assertions1 
You1re free to use
whatever library you like (or none at all), but I recommend jQuery1 You1ll 
often hear
that JavaScript libraries should be loaded last, right before the closing 
</body> tag1 There
is good reason for this, and we will learn some techniques to make this 
possible, but for
now, we1re going to include jQuery early11

Then, right before the closing </body> tag:

{{#if showTests}}

<div id="mocha"></div>

<script src="/vendor/mocha1js"></script>

<script src="/vendor/chai1js"></script>

<script>

mocha1ui('tdd');

var assert = chai1assert;

</script>

11  Remember the first principle of performance tuning: profile first, then 
optimize1


<script src="/qa/tests-global1js"></script>

{{#if pageTestScript}}

<script src="{{pageTestScript}}"></script>


</body>

{{/if}}

{{/if}}

<script>mocha1run();</script>

Note that Mocha and Chai get included, as well as a script called 
/qa/global-tests1js1 As
the name implies, these are tests that will be run on every page1 A little 
farther down,
we optionally link in page-specific tests, so that you can have different tests 
for different
pages1 We1ll start with the global tests, and then add page-specific tests1 
Let1s start with
a single, simple test: making sure the page has a valid title1 Create the 
directory public/
qa and create a file tests-global1js in it:

suite('Global Tests', function(){

test('page has a valid title', function(){
assert(document1title && document1title1match(/\S/) &&

document1title1toUpperCase() !== 'TODO');


});

});

Mocha supports multiple “interfaces,” which control the style of your
tests1 The default interface, behavior-driven development (BDD), is
tailored to make you think in a behavioral sense1 In BDD, you de‐
scribe components and their behaviors, and the tests then verify those
behaviors1 However, I find that very often, there are tests that don1t
fit      this model, and then the BDD language just looks strange1 Test-
driven  development  (TDD)  is  more  matter-of-fact:  you  describe
suites of tests and tests within the suite1 There1s nothing to stop you
from using both interfaces in your tests, but then it becomes a con‐
figuration hassle1 For that reason, I1ve opted to stick with TDD in this
book1    If you prefer BDD, or mixing BDD and TDD, by all means
do  so1

Go ahead and run the site now1 Visit the home page and examine the source: 
you1ll see
no evidence of test code1 Now, add test=1 to the querystring 
(http://localhost:3000/?
test=1), and you1ll see the tests run on the page1 Any time you want to test 
the site, all
you have to do is add test=1 to the querystring!

Now let1s add a page-specific test1 Let1s say that we want to ensure that a 
link to the yet-
to-be-created Contact page always exists on the About page1 We1ll create a file 
called
public/qa/tests-about1js:

suite('"About" Page Tests', function(){

test('page should contain link to contact page', function(){
assert($('a[href="/contact"]')1length);


});

});

We have one last thing to do: specify in the route which page test file the 
view should
be using1 Modify the About page route in meadowlark1js:

app1get('/about', function(req, res) {
res1render('about', {

fortune: fortune1getFortune(),
pageTestScript: '/qa/tests-about1js'

} );

});

Load the About page with test=1 in the querystring: you1ll see two suites and 
one failure!
Now add a link to the nonexistent Contact page, and you1ll see the test become 
successful
when you reload1

Depending on the nature of your site, you may want this to be more automatic1 
For
example, if your route was /foo, you could automatically set the page-specific 
tests to
be /foo/tests-foo1js1 The downside of this approach is that you lose 
flexibility1 For exam‐
ple, if you have multiple routes that point to the same view, or even very 
similar content,
you might want to use the same test file1

Let1s resist the temptation to add more tests now: those will come as we 
progress through
the book1 For now, we have the basic framework necessary to add global and page-
specific tests1

Cross-Page Testing

Cross-page testing is a little more challenging, because you need to be able to 
control
and observe the browser itself1 Let1s look at an example of a cross-page 
testing scenario1
Let1s say your website has a Request Group Rate page that contains a contact 
form1 The
marketing  department  wants  to  know  what  page  the  customer  was  last  
on  before
following a link to Request Group Rate—they want to know whether the customer 
was
viewing the Hood River tour or Oregon Coast retreat1 Hooking this up will 
require some
hidden form fields and JavaScript, and testing is going to involve going to a 
page, then
clicking  Request  Group  Rate  and  verifying  that  the  hidden  field  is  
populated
appropriately1

Let1s set up this scenario, and then see how we can test it1 First, we1ll 
create a tour page,

views/tours/hood-river1handlebars:

<h1>Hood River Tour</h1>

<a class="requestGroupRate"

href="/tours/request-group-rate">Request Group Rate1</a>

And a quote page, views/tours/request-group-rate1handlebars:


<h1>Request Group Rate</h1>

<form>


</form>

<input type="hidden" name="referrer">

Name: <input type="text" id="fieldName" name="name"><br>
Group size: <input type="text" name="groupSize"><br>
Email: <input type="email" name="email"><br>

<input type="submit" value="Submit">

<script>

$(document)1ready(function(){

$('input[name="referrer"]')1val(document1referrer);

});

</script>

Then we1ll create routes for these pages in meadowlark1js:

app1get('/tours/hood-river', function(req, res){
res1render('tours/hood-river');

});

app1get('/tours/request-group-rate', function(req, res){
res1render('tours/request-group-rate');

});

Now that we have something to test, we need some way to test it, and this is 
where things
get complicated1 To test this functionality, we really need a browser or 
something a lot
like a browser1 Obviously, we can do it by hand by going to the 
/tours/hood-river page
in  a browser, then clicking on the Request Group Rate link, then inspecting 
the hidden
form element to see that it1s correctly populated with the referring page, but 
that1s a lot
of work—we want a way to automate that1

What we1re looking for is often called a headless browser: meaning that the 
browser
doesn1t actually need to display something on the screen, necessarily, it just 
has to behave
like     a browser1 Currently, there are three popular solutions for this 
problem: Selenium,
PhantomJS, and Zombie1 Selenium is incredibly robust, with extensive testing 
support,
but configuring it is beyond the scope of this book1 PhantomJS is a great 
project and
actually provides a headless WebKit browser (the same engine used in Chrome and
Safari) so, like Selenium, it represents a very high level of realism1 However, 
it doesn1t
yet provide the simple test assertions that we1re looking for, which leaves us 
with Zombie1

Zombie doesn1t use an existing browser engine, so it isn1t suitable for testing 
browser
features, but it1s great for testing basic functionality, which is what we1re 
looking for1
Unfortunately, Zombie doesn1t currently support a Windows installation (it used 
to be
possible  through  Cygwin)1  People  have  gotten  it  to  work,  however,  and 
 there1s
information  on  the  Zombie  home  page1  I  have  made  an  effort  to  make  
this  book
platform-agnostic, but there currently isn1t a Windows solution for simple 
headless
browser         tests1 If you1re a Windows developer, I encourage you to check 
out Selenium
or PhantomJS: it will be a steeper learning curve, but these projects have a 
lot to offer1

First, install Zombie:


npm install --save-dev zombie

Now we1ll create a new directory called simply qa (distinct from public/qa)1 In 
that
directory, we1ll create a file, qa/tests-crosspage1js:

var Browser = require('zombie'),

assert = require('chai')1assert;

var browser;

suite('Cross-Page Tests', function(){
setup(function(){

browser = new Browser();

});

test('requesting a group rate quote     from the hood river tour page' +
'should populate the referrer field', function(done){

var referrer = 'http://localhost:3000/tours/hood-river';
browser1visit(referrer, function(){

browser1clickLink('1requestGroupRate', function(){
assert(browser1field('referrer')1value

=== referrer);


});

});

});

done();

test('requesting a group rate from the oregon coast tour page should ' +
'populate the referrer field', function(done){

var referrer = 'http://localhost:3000/tours/oregon-coast';
browser1visit(referrer, function(){

browser1clickLink('1requestGroupRate', function(){
assert(browser1field('referrer')1value

=== referrer);


});

});

});

done();

test('visiting the "request group rate" page dirctly should result ' +
'in an empty referrer field', function(done){

browser1visit('http://localhost:3000/tours/request-group-rate',

function(){

assert(browser1field('referrer')1value === '');
done();

});

});

});

setup takes a function that will get executed by the test framework before each 
test is
run: this is where we create a new browser instance for each test1 Then we have 
three


tests1 The first two check that the referrer is populated correctly if you1re 
coming from
a product page1 The browser1visit method will actually load a page; when the 
page
has been loaded, the callback function is invoked1 Then the browser1clickLink 
method
looks for a link with the requestGroupRate class and follows it1 When the 
linked page
loads, the callback function is invoked, and now we1re on the Request Group 
Rate page1
All that remains to be done is to assert that the hidden “referrer” field 
correctly matches
the original page we visited1 The browser1field method returns a DOM Element
object, which has a value property1 The last test simply ensures that the 
referrer is blank
if    the Request Group Rate page is visited directly1

Before we run the tests, you1ll have to start the server (node meadowlark1js)1 
You1ll
want to do that in a different window so you can see any console errors1 Then 
run the
test   and   see   how   we   did   (make   sure   you   have   Mocha   
installed   globally:
npm install -g mocha):

mocha -u tdd -R spec qa/tests-crosspage1js 2>/dev/null

We1ll see that one of our tests is failing…it failed for the Oregon Coast Tour 
page, which
should be no surprise, since we haven1t added that page yet1 But the other two 
tests are
passing! So our test is working; go ahead and add an Oregon Coast Tour page, 
and all
of      the tests will pass1 Note that in the previous command, I specified 
that our interface
is TDD (it defaults to BDD) and to use a reporter called spec1 The spec 
reporter provides
a bit more information than the default reporter1 (Once you have hundreds of 
tests, you
might want to switch back to the default reporter1) Finally, you1ll note that 
we1re dumping
the error output (2>/dev/null)1 Mocha reports all of the stack traces for 
failed tests1 It
can be useful information, but usually you just want to see what tests are 
passing and
what tests are failing1 If you need more information, leave the 2>/dev/null off 
and you
will see the error detail1

One advantage of writing your tests before you implement features is
that (if your tests are correct), they will all start out failing1 Not only
does this give you satisfaction as you see your tests start to pass, but
it1s additional assurance that the test is correct1 If your test starts out
passing  before  you  even  implement  a  feature,  the  test  is  probably
broken1 This is sometimes called “red light, green light” testing1

Logic Testing

We1ll also be using Mocha for logic testing1 For now, we have only one tiny bit 
of func‐
tionality (the fortune generator), so setting this up will be pretty easy1 
Also, since we
only have one component, we don1t have enough for integration tests, so we1ll 
just be
adding unit tests1 Create the file qa/tests-unit1js:


var fortune = require('11/lib/fortune1js');

var expect = require('chai')1expect;
suite('Fortune cookie tests', function(){

test('getFortune() should return a fortune', function(){
expect(typeof fortune1getFortune() === 'string');

});

});

Now we can just run Mocha against this new test suite:

mocha -u tdd -R spec qa/tests-unit1js

Not very exciting! But it provides the template that we will be using 
throughout the rest
of this book1

Testing entropic functionality (functionality that is random) comes
with its own challenges1 Another test we could add for our fortune
cookie generator would be a test to make sure that it returns a ran‐
dom fortune cookie1 But how do you know if something is random?
One approach is to get a large number of fortunes—a thousand, for
example—and then measure the distribution of the responses1 If the
function     is properly random, no one response will stand out1 The
downside of this approach is that it1s nondeterministic: it1s possible
(but unlikely) to get one fortune 10 times more frequently than any
other fortune1 If that happened, the test could fail (depending on how
aggressive you set the threshold of what is “random”), but that might
not actually indicate that the system being tested is failing; it1s just a
consequence of testing entropic systems1 In the case of our fortune
generator,   it would be reasonable to generate 50 fortunes, and expect
at      least three different ones1 On the other hand, if we were develop‐
ing a random source for a scientific simulation or security compo‐
nent, we would probably want to have much more detailed tests1 The
point is that testing entropic functionality is difficult and requires
more thought1

Linting

A good linter is like having a second set of eyes: it will spot things that 
will slide right
past our human brains1 The original JavaScript linter is Douglas Crockford1s 
JSLint1 In
2011, Anton Kovalyov forked JSLint, and JSHint was born1 Kovalyov found that 
JSLint
was  becoming  too  opinionated,  and  he  wanted  to  create  a  more  
customizable,
community-developed JavaScript linter1 While I agree with almost all of 
Crockford1s


linting suggestions, I prefer the ability to tailor my linter, and for that 
reason, I recom‐
mend JSHint12

JSHint is very easy to get via npm:

npm install -g jshint

To run it, simply invoke it with the name of a source file:

jshint meadowlark1js

If you1ve been following along, JSHint shouldn1t have any complaints about 
meadow‐
lark1js1 To see the kind of thing that JSHint will save you from, put the 
following line in
meadowlark1js, and run JSHint on it:

if( app1thing == null ) console1log( 'bleat!' );

(JSHint will complain about using == instead of ===, whereas JSLint would 
additionally
complain about the lack of curly brackets1)

Consistent use of a linter will make you a better programmer: I promise that1 
Given
that, wouldn1t it be nice if your linter integrated into your editor and you 
were informed
of potential errors as soon as you made them? Well, you1re in luck1 JSHint 
integrates
into many popular editors1

Link Checking

Checking for dead links doesn1t seem very glamorous, but it can have a huge 
impact on
how your website is ranked by search engines1 It1s an easy enough thing to 
integrate into
your workflow, so it1s foolish not to1

I recommend LinkChecker; it1s cross-platform, and it offers a command-line as 
well as
a graphical interface1 Just install it and point it at your home page:

linkchecker http://localhost:3000

Our site doesn1t have very many pages yet, so LinkChecker should whip right 
through
it1

Automating with Grunt

The QA tools we1re using—test suites, linting, link checkers—provide value only 
if
they1re actually used, and this is where many a QA plan withers and dies1 If 
you have to
remember all the components in your QA toolchain and all the commands to run 
them,
the chances that you (or other developers you work with) will reliably use them 
go down
considerably1  If  you1re  going  to  invest  the  time  required  to  come  up 
 with  a

21  Nicholas Zakas1s ESLint is also an excellent choice1


comprehensive QA toolchain, isn1t it worth spending a little time automating 
the process
so that the toolchain will actually be used?

Fortunately, a tool called Grunt makes automating these tasks quite easy1 We1ll 
be rolling
up our logic tests, cross-page tests, linting, and link checking into a single 
command
with Grunt1 Why not page tests? This is possible using a headless browser like 
Phan‐
tomJS or Zombie, but the configuration is complicated and beyond the scope of 
this
book1 Furthermore, browser tests are usually designed to be run as you work on 
an
individual page, so there isn1t quite as much value in rolling them together 
with the rest
of      your tests1

First, you1ll need to install the Grunt command line, and Grunt itself:

sudo npm install -g grunt-cli
npm install --save-dev grunt

Grunt relies on plugins to get the job done (see the Grunt plugins list for all 
available
plugins)1 We1ll need plugins for Mocha, JSHint, and LinkChecker1 As I write 
this, there1s
no plugin for LinkChecker, so we1ll have to use a generic plugin that executes 
arbitrary
shell commands1 So first we install all the necessary plugins:

npm install --save-dev grunt-cafe-mocha

npm install --save-dev grunt-contrib-jshint
npm install --save-dev grunt-exec

Now that all the plugins have been installed, create a file in your project 
directory called

Gruntfile1js:

module1exports = function(grunt){

// load plugins

[

'grunt-cafe-mocha',
'grunt-contrib-jshint',
'grunt-exec',

]1forEach(function(task){

grunt1loadNpmTasks(task);

});

// configure plugins

grunt1initConfig({

cafemocha: {

all: { src: 'qa/tests-*1js', options: { ui: 'tdd' }, }

},

jshint: {

app: ['meadowlark1js', 'public/js/**/*1js',
'lib/**/*1js'],

qa: ['Gruntfile1js', 'public/qa/**/*1js', 'qa/**/*1js'],

},

exec: {

linkchecker:


{ cmd: 'linkchecker http://localhost:3000' }

},

});

// register tasks

grunt1registerTask('default', ['cafemocha','jshint','exec']);

};

In the section “load plugins,” we1re specifying which plugins we1ll be using, 
which are
the same plugins we installed via npm1 Because I don1t like to have to type 
loadNpm
Tasks over and over again (and once you start relying on Grunt more, believe 
me, you
will be adding more plugins!), I choose to put them all in an array and loop 
over them
with forEach1

In the “configure plugins” section, we have to do a little work to get each 
plugin to work
properly1  For  the  cafemocha plugin  (which  will  run  our  logic  and  
cross-browser
tests),  we  have  to  tell  it  where  our  tests  are1  We1ve  put  all  of  
our  tests  in  the  qa
subdirectory, and named them with a tests- prefix1 Note that we have to specify 
the tdd
interface1 If you were mixing TDD and BDD, you would have to have some way to
separate them1 For example, you could use prefixes tests-tdd- and tests-bdd-1

For JSHint, we have to specify what JavaScript files should be linted1 Be 
careful here!
Very often, dependencies won1t pass JSHint cleanly, or they will be using 
different JSHint
settings, and you1ll be inundated with JSHint errors for code that you didn1t 
write1 In
particular, you want to make sure the node_modules directory isn1t included, as 
well as
any  vendor  directories1  Currently,  grunt-contrib-jshint doesn1t  allow  you 
 to  ex‐
clude files, only include them1 So we have to specify all the files we want to 
include1 I
generally break the files I want to include into two lists: the JavaScript that 
actually makes
up     our application or website and the QA JavaScript1 It all gets linted, 
but breaking it
up like this makes it a little easier to manager1 Note that the wildcard /**/ 
means “all
files in all subdirectories1” Even though we don1t have a public/js directory 
yet, we will1
Implicitly excluded are the node_modules and public/vendor directories1

Lastly, we configure the grunt-exec plugin to run LinkChecker1 Note that we1ve 
hard‐
coded this plugin to use port 3000; this might be a good thing to parameterize, 
which
I1ll leave as an exercise for the reader13

Finally, we “register” the tasks: this puts individual plugins into named 
groups1 A spe‐
cially named task, default, will be the task that gets run by default, if you 
just type grunt1

31  See the grunt1option documentation to get started1


Now all you have to do is make sure a server is running (in the background or 
in a
different window), and run Grunt:

grunt

All of your tests will run (minus the page tests), all your code gets linted, 
and all your
links are checked! If any component fails, Grunt will terminate with an error 
message;
otherwise, it will report “Done, without errors1” There1s nothing quite so 
satisfying as
seeing that message, so get in the habit of running Grunt before you commit!

Continuous Integration (CI)

I1ll leave you with another extremely useful QA concept: continuous 
integration1 It1s
especially important if you1re working on a team, but even if you1re working on 
your
own, it can provide some discipline that you might otherwise lack1 Basically, 
CI runs
some or all of your tests every time you contribute code to a shared server1 If 
all of the
tests pass, nothing usually happens (you may get an email saying “good job,” 
depending
on how your CI is configured)1 If, on the other hand, there are failures, the 
consequences
are usually more…public1 Again, it depends on how you configure your CI, but 
usually
the entire team gets an email saying that you “broke the build1” If your 
integration master
is really sadistic, sometimes your boss is also on that email list! I1ve even 
known teams
that set up lights and sirens when someone breaks the build, and in one 
particularly
creative office, a tiny robotic foam missile launcher fired soft projectiles at 
the offending
developer! It1s a powerful incentive to run your QA toolchain before 
committing1

It1s beyond the scope of this book to cover installing and configuring a CI 
server, but a
chapter on QA wouldn1t be complete without mentioning it1 Currently, the most 
popular
CI server for Node projects is Travis CI1 Travis CI is a hosted solution, which 
can be
very appealing (it saves you from having to set up your own CI server)1 If 
you1re using
GitHub, it offers excellent integration support1 Jenkins, a well-established CI 
server, now
has a Node plugin1 JetBrains1s excellent TeamCity now offers Node plugins1

If you1re working on a project on your own, you may not get much benefit from a 
CI
server, but if you1re working on a team or an open source project, I highly 
recommend
looking into setting up CI for your project1


CHAPTER 6

The Request and Response Objects

When you1re building a web server with Express, most of what you1ll be doing 
starts
with a request object and ends with a response object1 These two objects 
originate in
Node and are extended by Express1 Before we delve into what these objects offer 
us, let1s
establish a little background on how a client (a browser, usually) requests a 
page from
a  server, and how that page is returned1

The Parts of a URL

Protocol

The protocol determines how the request will be transmitted1 We will be dealing
exclusively with http and https1 Other common protocols include file and ftp1

Host

The host identifies the server1 Servers on your computer (localhost) or a local 
net‐
work may simply be one word, or it may be a numeric IP address1 On the Internet,
the host will end in a top-level domain (TLD) like 1com or 1net1 Additionally, 
there
may be subdomains, which prefix the hostname1 www is a very common subdo‐
main, though it can be anything1 Subdomains are optional1


Port

Each server has a collection of numbered ports1 Some port numbers are “special,”
like 80 and 4431 If you omit the port, port 80 is assumed for HTTP and 443 for
HTTPS1 In general, if you aren1t using port 80 or 443, you should use a port 
number
greater than 102311  It1s very common to use easy-to-remember port numbers like
3000, 8080, and 80881

Path

The path is generally the first part of the URL that your app cares about (it 
is possible
to make decisions based on protocol, host, and port, but it1s not good 
practice)1 The
path should be used to uniquely identify pages or other resources in your app1

Querystring

The querystring is an optional collection of name/value pairs1 The querystring
starts with a question mark (?), and name/value pairs are separated by 
ampersands
(&)1 Both names and values should be URL encoded1 JavaScript provides a built-in
function to do that: encodeURIComponent1 For example, spaces will be replaced 
with
plus signs (+)1 Other special characters will be replaced with numeric character
references1

Fragment

The fragment (or hash) is not passed to the server at all: it is strictly for 
use by the
browser1 It is becoming increasingly common for single-page applications or 
AJAX-
heavy applications to use the fragment to control the application1 Originally, 
the
fragment1s sole purpose was to cause the browser to display a specific part of 
the
document, marked by an anchor tag (<a id="chapter06">)1

HTTP Request Methods

The HTTP protocol defines a collection of request methods (often referred to as 
HTTP
verbs) that a client uses to communicate with a server1 Far and away, the most 
common
methods are GET and POST1

When you type a URL into a browser (or click a link), the browser issues an 
HTTP GET
request to the server1 The important information passed to the server is the 
URL path
and querystring1 The combination of method, path, and querystring is what your 
app
uses to determine how to respond1

For a website, most of your pages will respond to GET requests1 POST requests 
are usually
reserved for sending information back to the server (form processing, for 
example)1 It1s
quite common for POST requests to respond with the same HTML as the 
corresponding
GET request after the server has processed any information included in the 
request (like

11  Ports 0-1023 are “well-known ports1”


a form)1 Browsers will exclusively use the GET and POST methods when 
communicating
with your server (if they1re not using AJAX)1

Web services, on the other hand, often get more creative with the HTTP methods 
used1
For example, there1s an HTTP method called DELETE that is useful for, well, an 
API call
that deletes things1

With Node and Express, you are fully in charge of what methods you respond to 
(though
some of the more esoteric ones are not very well supported)1 In Express, you1ll 
usually
be writing handlers for specific methods1

Request Headers

The URL isn1t the only thing that1s passed to the server when you navigate to a 
page1
Your browser is sending a lot of “invisible” information every time you visit a 
website1
I1m not talking about spooky personal information (though if your browser is 
infected
by malware, that can happen)1 The browser will tell the server what language it 
prefers
to receive the page in (for example, if you download Chrome in Spain, it will 
request
the Spanish version of pages you visit, if they exist)1 It will also send 
information about
the “user agent” (the browser, operating system, and hardware) and other bits 
of infor‐
mation1 All this information is sent as a request header, which is made 
available to you
through the request object1s headers property1 If you1re curious to see the 
information
your browser is sending, you can create a very simple Express route to display 
that
information:

app1get('/headers', function(req,res){
res1set('Content-Type','text/plain');
var                                      s = '';

for(var name in req1headers) s += name + ': ' + req1headers[name] + '\n';
res1send(s);

});

Response Headers

Just as your browser sends hidden information to the server in the form of 
request
headers, when the server responds, it also sends information back that is not 
necessarily
rendered or displayed by the browser1 The information typically included in 
response
headers is metadata and server information1 We1ve already seen the Content-Type
header, which tells the browser what kind of content is being transmitted 
(HTML, an
image, CSS, JavaScript, etc1)1 Note that the browser will respect the 
Content-Type header
regardless of what the URL path is1 So you could serve HTML from a path of 
/image1jpg
or      an image from a path of /text1html1 (There1s no legitimate reason to do 
this; it1s just
important to understand that paths are abstract, and the browser uses 
Content-Type to
determine how to render content1) In addition to Content-Type, headers can 
indicate
whether the response is compressed and what kind of encoding it1s using1 
Response

Request Headers    |    55


headers can also contain hints for the browser about how long it can cache the 
resource1
This is an important consideration for optimizing your website, and we1ll be 
discussing
that in detail in Chapter 161 It is also common for response headers to contain 
some
information about the server, indicating what type of server it is, and 
sometimes even
details about the operating system1 The downside about returning server 
information
is  that it gives hackers a starting point to compromise your site1 Extremely 
security-
conscious servers often omit this information, or even provide false 
information1
Disabling Express1s default X-Powered-By header is easy:

app1disable('x-powered-by');

If you want to see the response headers, they can be found in your browser1s 
developer
tools1 To see the response headers in Chrome, for example:

11  Open the JavaScript console1

21  Click the Network tab1

31  Reload the page1

41  Pick the HTML from the list of requests (it will be the first one)1

51  Click the Headers tab; you will see all response headers1

Internet Media Types

The Content-Type header is critically important: without it, the client would 
have to
painfully guess how to render the content1 The format of the Content-Type 
header is
an Internet media type, which consists of a type, subtype, and optional 
parameters1 For
example, text/html; charset=UTF-8 specifies a type of “text,” a subtype of 
“html,” and
a character encoding of UTF-81 The Internet Assigned Numbers Authority maintains
an official list of Internet media types1 Often, you will hear “content type,” 
“Internet
media type,” and “MIME type” used interchangeably1 MIME (Multipurpose Internet
Mail Extensions) was a precursor of Internet media types and, for the most 
part, is
equivalent1

Request Body

In addition to the request headers, a request can have a body (just like the 
body of a
response is the actual content that1s being returned)1 Normal GET requests 
don1t have
bodies, but POST requests usually do1 The most common media type for POST 
bodies is
application/x-www-form-urlencoded,  which  is  simply  encoded  name/value  
pairs
separated by ampersands (essentially the same format as a querystring)1 If the 
POST
needs to support file uploads, the media type is multipart/form-data, which is 
a more
complicated format1 Lastly, AJAX requests can use application/json for the 
body1


Parameters

The word “parameters” can mean a lot of things, and is often a source of 
confusion1 For
any request, parameters can come from the querystring, the session (requiring 
cookies;
see Chapter 9), the request body, or the named routing parameters (which we1ll 
learn
more about in Chapter 14)1 In Node applications, the param method of the 
request object
munges all of these parameters together1 For this reason, I encourage you to 
avoid it1
This commonly causes problems when a parameter is set to one thing in the 
querystring
and another one in the POST body or the session: which value wins? It can 
produce
maddening bugs1 PHP is largely to blame for this confusion: in an effort to be 
“conve‐
nient,”        it munged all of these parameters into a variable called 
$_REQUEST, and for some
reason, people have thought it was a good idea ever since1 We will learn about 
dedicated
properties that hold the various types of parameters, and I feel that that is a 
much less
confusing approach1

The Request Object

The request object (which is normally passed to a callback, meaning you can 
name it
whatever you want: it is common to name it req or request) starts its life as 
an instance
of http1IncomingMessage, a core Node object1 Express adds additional 
functionality1
Let1s look at the most useful properties and methods of the request object (all 
of these
methods are added by Express, except for req1headers and req1url, which 
originate
in Node):

req1params

An array containing the named route parameters1 We1ll learn more about this in
Chapter 141

req1param(name)

Returns the named route parameter, or GET or POST parameters1 I recommend
avoiding this method1

req1query

An object containing querystring parameters (sometimes called GET parameters)
as name/value pairs1

req1body

An object containing POST parameters1 It is so named because POST parameters are
passed in the body of the REQUEST, not in the URL like querystring parameters1 
To
make req1body available, you1ll need middleware that can parse the body content
type, which we will learn about in Chapter 101

Parameters    |    57


req1route

Information  about  the  currently  matched  route1  Primarily  useful  for  
route
debugging1

req1cookies/req1signedCookies

Objects containing containing cookie values passed from the client1 See Chapter 
91

req1headers

The request headers received from the client1

req1accepts([types])

A convenience method to determine whether the client accepts a given type or 
types
(optional types can be a single MIME type, such as application/json, a comma-
delimited list, or an array)1 This method is of primary interest to those 
writing public
APIs;     it is assumed that browsers will always accept HTML by default1

req1ip

The IP address of the client1

req1path

The request path (without protocol, host, port, or querystring)1

req1host

A convenience method that returns the hostname reported by the client1 This in‐
formation can be spoofed and should not be used for security purposes1

req1xhr

A convenience property that returns true if the request originated from an AJAX
call1

req1protocol

The protocol used in making this request (for our purposes, it will either be 
http

or https)1

req1secure

A convenience property that returns true if the connection is secure1 Equivalent
to req1protocol==='https'1

req1url/req1originalUrl

A bit of a misnomer, these properties return the path and querystring (they do 
not
include protocol, host, or port)1 req1url can be rewritten for internal routing
purposes, but req1originalUrl is designed to remain the original request and
querystring1

req1acceptedLanguages

A convenience method that returns an array of the (human) languages the client
prefers, in order1 This information is parsed from the request header1


The Response Object

The response object (which is normally passed to a callback, meaning you can 
name it
whatever you want: it is common to name it res, resp, or response) starts its 
life as an
instance of http1ServerResponse, a core Node object1 Express adds additional 
func‐
tionality1 Let1s look at the most useful properties and methods of the response 
object (all
of these are added by Express):

res1status(code)

Sets the HTTP status code1 Express defaults to 200 (OK), so you will have to use
this method to return a status of 404 (Not Found) or 500 (Server Error), or any
other status code you wish to use1 For redirects (status codes 301, 302, 303, 
and
307), there is a method redirect, which is preferable1

res1set(name, value)

Sets a response header1 This is not something you will normally be doing 
manually1

res1cookie(name, value, [options]), res1clearCookie(name, [options])

Sets or clears cookies that will be stored on the client1 This requires some 
middle‐
ware support; see Chapter 91

res1redirect([status], url)

Redirects the browser1 The default redirect code is 302 (Found)1 In general, you
should minimize redirection unless you are permanently moving a page, in which
case you should use the code 301 (Moved Permanently)1

res1send(body), res1send(status, body)

Sends a response to the client, with an optional status code1 Express defaults 
to a
content type of text/html, so if you want to change it to text/plain (for 
example),
you1ll  have  to  call  res1set('Content-Type', 'text/plain\') before  calling
res1send1 If body is an object or an array, the response is sent as JSON 
instead (with
the content type being set appropriately), though if you want to send JSON, I 
rec‐
ommend doing so explicitly by calling res1json instead1

res1json(json), res1json(status, json)

Sends JSON to the client with an optional status code1

res1jsonp(json), res1jsonp(status, json)


