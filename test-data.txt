Web Development with
Node and Express

Ethan Brown


Web Development with Node and Express

by Ethan Brown

Copyright © 2014 Ethan Brown1 All rights reserved1
Printed in the United States of America1

Published by O1Reilly Media, Inc1, 1005 Gravenstein Highway North, Sebastopol, 
CA 954721

O1Reilly books may be purchased for educational, business, or sales promotional 
use1 Online editions are
also available for most titles (http://my1safaribooksonline1com)1 For more 
information, contact our corporate/
institutional sales department: 800-998-9938 or corporate@oreilly1com1


Editors: Simon St1 Laurent and Brian Anderson

Production Editor: Matthew Hacker
Copyeditor: Linley Dolby
Proofreader:    Rachel Monaghan

July 2014:                  First Edition

Revision History for the First Edition:

2014-06-27:    First release

Indexer: Ellen Troutman Zaig
Cover Designer: Karen Montgomery
Interior Designer: David Futato
Illustrator: Rebecca Demarest

See http://oreilly1com/catalog/errata1csp?isbn=9781491949306 for release 
details1

Nutshell Handbook, the Nutshell Handbook logo, and the O1Reilly logo are 
registered trademarks of O1Reilly
Media, Inc1 Web Development with Node and Express, the picture of a black lark 
and a white-winged lark,
and related trade dress are trademarks of O1Reilly Media, Inc1

Many of the designations used by manufacturers and sellers to distinguish their 
products are claimed as
trademarks1 Where those designations appear in this book, and O1Reilly Media, 
Inc1 was aware of a trademark
claim, the designations have been printed in caps or initial caps1

While every precaution has been taken in the preparation of this book, the 
publisher and author assume no
responsibility for errors or omissions, or for damages resulting from the use 
of the information contained
herein1

ISBN: 978-1-491-94930-6
[LSI]


This book is dedicated to my family:

My father, Tom, who gave me a love of engineering; my mother, Ann, who gave me 
a love
of writing; and my sister, Meris, who has been a constant companion1



Table of Contents

Foreword1                                                                       
                                           xiii

Preface1                                                                        
                                              xv

11  Introducing Express1                                                        
                                        1

The JavaScript Revolution                                                       
                              1

Introducing Express                                                             
                                 2

A Brief History of Express                                                      
                              4

Upgrading to Express 410                                                        
                              4

Node: A New Kind of Web Server                                                  
                       5

The Node Ecosystem                                                              
                              6

Licensing                                                                       
                                       7

21  Getting Started with Node1                                                  
                                     9

Getting Node                                                                    
                                    9

Using the Terminal                                                              
                                10

Editors                                                                         
                                       11

npm                                                                             
                                       12

A Simple Web Server with Node                                                   
                      13

Hello World                                                                     
                                14

Event-Driven Programming                                                        
                    14

Routing                                                                         
                                  15

Serving Static Resources                                                        
                           15

Onward to Express                                                               
                               17

31  Saving Time with Express1                                                   
                                    19

Scaffolding                                                                     
                                     19

The Meadowlark Travel Website                                                   
                      20

Initial Steps                                                                   
                                      20

Views and Layouts                                                               
                            24


Static Files and Views                                                          
                             26

Dynamic Content in Views                                                        
                      27

Conclusion                                                                      
                                28

41  Tidying Up1                                                                 
                                           29

Best Practices                                                                  
                                    29

Version Control                                                                 
                                 30

How to Use Git with This Book                                                   
                        30

If You1re Following Along by Doing It Yourself                                  
               31

If You1re Following Along by Using the Official Repository                      
        32

npm Packages                                                                    
                                 33

Project Metadata                                                                
                                 34

Node Modules                                                                    
                                34

51  Quality Assurance1                                                          
                                       37

QA: Is It Worth It?                                                             
                                  38

Logic Versus Presentation                                                       
                            39

The Types of Tests                                                              
                                 39

Overview of QA Techniques                                                       
                         40

Running Your Server                                                             
                              40

Page Testing                                                                    
                                    41

Cross-Page Testing                                                              
                                44

Logic Testing                                                                   
                                    47

Linting                                                                         
                                       48

Link Checking                                                                   
                                 49

Automating with Grunt                                                           
                           49

Continuous Integration (CI)                                                     
                          52

61  The Request and Response Objects1                                           
                              53

The Parts of a URL                                                              
                                53

HTTP Request Methods                                                            
                          54

Request Headers                                                                 
                                55

Response Headers                                                                
                               55

Internet Media Types                                                            
                              56

Request Body                                                                    
                                  56

Parameters                                                                      
                                    57

The Request Object                                                              
                               57

The Response Object                                                             
                             59

Getting More Information                                                        
                          60

Boiling It Down                                                                 
                                 61

Rendering Content                                                               
                           61

Processing Forms                                                                
                             63


Providing an API                                                                
                             64

71  Templating with Handlebars1                                                 
                                 67

There Are No Absolute Rules Except This One                                     
              68

Choosing a Template Engine                                                      
                         69

Jade: A Different Approach                                                      
                           69

Handlebars Basics                                                               
                                71

Comments                                                                        
                               72

Blocks                                                                          
                                    72

Server-Side Templates                                                           
                           74

Views and Layouts                                                               
                            74

Using Layouts (or Not) in Express                                               
                     76

Partials                                                                        
                                    77

Sections                                                                        
                                   79

Perfecting Your Templates                                                       
                         80

Client-Side Handlebars                                                          
                          81

Conclusion                                                                      
                                   83

81  Form Handling1                                                              
                                        85

Sending Client Data to the Server                                               
                         85

HTML Forms                                                                      
                                85

Encoding                                                                        
                                    86

Different Approaches to Form Handling                                           
                  87

Form Handling with Express                                                      
                         89

Handling AJAX Forms                                                             
                           90

File Uploads                                                                    
                                    92

jQuery File Upload                                                              
                                94

91  Cookies and Sessions1                                                       
                                      99

Externalizing Credentials                                                       
                           100

Cookies in Express                                                              
                              101

Examining Cookies                                                               
                            103

Sessions                                                                        
                                    103

Memory Stores                                                                   
                           103

Using Sessions                                                                  
                             104

Using Sessions to Implement Flash Messages                                      
              105

What to Use Sessions For                                                        
                          106

101  Middleware1                                                                
                                        109

Common Middleware                                                               
                        114


Third-Party Middleware                                                          
                         116

111  Sending Email1                                                             
                                        117

SMTP, MSAs, and MTAs                                                            
                       117

Receiving Email                                                                 
                               118

Email Headers                                                                   
                                118

Email Formats                                                                   
                                119

HTML Email                                                                      
                               119

Nodemailer                                                                      
                                 120

Sending Mail                                                                    
                              120

Sending Mail to Multiple Recipients                                             
                  121

Better Options for Bulk Email                                                   
                        122

Sending HTML Email                                                              
                         122

Images in HTML Email                                                            
                     123

Using Views to Send HTML Email                                                  
               123

Encapsulating Email Functionality                                               
                  125

Email as a Site Monitoring Tool                                                 
                        127

121  Production Concerns1                                                       
                                     129

Execution Environments                                                          
                         129

Environment-Specific Configuration                                              
                   130

Scaling Your Website                                                            
                             131

Scaling Out with App Clusters                                                   
                    132

Handling Uncaught Exceptions                                                    
                  135

Scaling Out with Multiple Servers                                               
                   138

Monitoring Your Website                                                         
                         139

Third-Party Uptime Monitors                                                     
                   139

Application Failures                                                            
                           140

Stress Testing                                                                  
                                  140

131  Persistence1                                                               
                                          143

Filesystem Persistence                                                          
                             143

Cloud Persistence                                                               
                               145

Database Persistence                                                            
                             146

A Note on Performance                                                           
                      146

Setting Up MongoDB                                                              
                       147

Mongoose                                                                        
                              147

Database Connections with Mongoose                                              
             148

Creating Schemas and Models                                                     
                   149

Seeding Initial Data                                                            
                            150

Retrieving Data                                                                 
                             151

Adding Data                                                                     
                             152


Using MongoDB for Session Storage                                               
               154

141  Routing1                                                                   
                                           157

Routes and SEO                                                                  
                              159

Subdomains                                                                      
                                159

Route Handlers Are Middleware                                                   
                    160

Route Paths and Regular Expressions                                             
                   162

Route Parameters                                                                
                              162

Organizing Routes                                                               
                             163

Declaring Routes in a Module                                                    
                       164

Grouping Handlers Logically                                                     
                       165

Automatically Rendering Views                                                   
                     166

Other Approaches to Route Organization                                          
               167

151  REST APIs and JSON1                                                        
                                     169

JSON and XML                                                                    
                             170

Our API                                                                         
                                   170

API Error Reporting                                                             
                            171

Cross-Origin Resource Sharing (CORS)                                            
                172

Our Data Store                                                                  
                                173

Our Tests                                                                       
                                   173

Using Express to Provide an API                                                 
                      175

Using a REST Plugin                                                             
                            176

Using a Subdomain                                                               
                            178

161  Static Content1                                                            
                                         181

Performance Considerations                                                      
                       182

Future-Proofing Your Website                                                    
                       182

Static Mapping                                                                  
                             183

Static Resources in Views                                                       
                        185

Static Resources in CSS                                                         
                         185

Static Resources in Server-Side JavaScript                                      
                    187

Static Resources in Client-Side JavaScript                                      
                    187

Serving Static Resources                                                        
                            189

Changing Your Static Content                                                    
                       190

Bundling and Minification                                                       
                         190

Skipping Bundling and Minification in Development Mode                          
 193

A Note on Third-Party Libraries                                                 
                      195

QA                                                                              
                                      195

Summary                                                                         
                                 197

171  Implementing MVC in Express1                                               
                               199


Models                                                                          
                                    200

View Models                                                                     
                                201

Controllers                                                                     
                                   203

Conclusion                                                                      
                                  205

181  Security1                                                                  
                                            207

HTTPS                                                                           
                                  207

Generating Your Own Certificate                                                 
                  208

Using a Free Certificate Authority                                              
                    209

Purchasing a Certificate                                                        
                         210

Enabling HTTPS for Your Express App                                             
             212

A Note on Ports                                                                 
                            213

HTTPS and Proxies                                                               
                        214

Cross-Site Request Forgery                                                      
                         215

Authentication                                                                  
                                216

Authentication Versus Authorization                                             
                216

The Problem with Passwords                                                      
                   217

Third-Party Authentication                                                      
                      217

Storing Users in Your Database                                                  
                    218

Authentication Versus Registration and the User Experience                      
    219

Passport                                                                        
                                 220

Role-Based Authorization                                                        
                      229

Adding Additional Authentication Providers                                      
           231

Conclusion                                                                      
                                  232

191  Integrating with Third-Party APIs1                                         
                                233

Social Media                                                                    
                                  233

Social Media Plugins and Site Performance                                       
             233

Searching for Tweets                                                            
                          234

Rendering Tweets                                                                
                          237

Geocoding                                                                       
                                 241

Geocoding with Google                                                           
                      241

Geocoding Your Data                                                             
                        242

Displaying a Map                                                                
                           245

Improving Client-Side Performance                                               
                247

Weather Data                                                                    
                                248

Conclusion                                                                      
                                  249

201  Debugging1                                                                 
                                        251

The First Principle of Debugging                                                
                       251

Take Advantage of REPL and the Console                                          
               252

Using Node1s Built-in Debugger                                                  
                      253


Node Inspector                                                                  
                               253

Debugging Asynchronous Functions                                                
                 257

Debugging Express                                                               
                             257

211  Going Live1                                                                
                                          261

Domain Registration and Hosting                                                 
                    261

Domain Name System                                                              
                     262

Security                                                                        
                                  262

Top-Level Domains                                                               
                         263

Subdomains                                                                      
                             264

Nameservers                                                                     
                             265

Hosting                                                                         
                                 266

Deployment                                                                      
                             269

Conclusion                                                                      
                                  272

221  Maintenance1                                                               
                                       273

The Principles of Maintenance                                                   
                       273

Have a Longevity Plan                                                           
                         273

Use Source Control                                                              
                          275

Use an Issue Tracker                                                            
                           275

Exercise Good Hygiene                                                           
                       275

Don1t Procrastinate                                                             
                           276

Do Routine QA Checks                                                            
                      276

Monitor Analytics                                                               
                           277

Optimize Performance                                                            
                       277

Prioritize Lead Tracking                                                        
                         277

Prevent “Invisible” Failures                                                    
                        279

Code Reuse and Refactoring                                                      
                        279

Private npm Registry                                                            
                          280

Middleware                                                                      
                              281

Conclusion                                                                      
                                  283

231  Additional Resources1                                                      
                                     285

Online Documentation                                                            
                         285

Periodicals                                                                     
                                   286

Stack Overflow                                                                  
                                286

Contributing to Express                                                         
                           288

Conclusion                                                                      
                                  290

Index1                                                                          
                                            291



Foreword

The combination of JavaScript, Node, and Express is an ideal choice for web 
teams that
want a powerful, quick-to-deploy technology stack that is widely respected in 
the de‐
velopment community and large enterprises alike1

Building great web applications and finding great web developers isn1t easy1 
Great apps
require great functionality, user experience, and business impact: delivered, 
deployed,
and supported quickly and cost effectively1 The lower total cost of ownership 
and faster
time-to-market that Express provides is critical in the business world1 If you 
are a web
developer,    you have to use at least some JavaScript1 But you also have the 
option of using
a            lot of it1 In this book, Ethan Brown shows you that you can use a 
lot of it, and it1s not
that hard thanks to Node and Express1

Node and Express are like machine guns that deliver upon the silver-bullet 
promise of
JavaScript1

JavaScript is the most universally accepted language for client-side scripting1 
Unlike
Flash, it1s supported by all major web browsers1 It1s the fundamental 
technology behind
many of the attractive animations and transitions you see on the Web1 In fact, 
it1s almost
impossible  not  to  utilize  JavaScript  if  you  want  to  achieve  modern  
client-side
functionality1

One problem with JavaScript is that it has always been vulnerable to sloppy 
program‐
ming1 The Node ecosystem is changing that by providing frameworks, libraries, 
and
tools that speed up development and encourage good coding habits1 This helps us 
bring
better apps to market faster1

We now have a great programming language that is supported by large 
enterprises, is
easy-to-use, is designed for modern browsers, and is supplemented with great 
frame‐
works and libraries on both client-side and server-side1 I call that 
revolutionary1

—Steve Rosenbaum

President and CEO, Pop Art, Inc1



Preface

Who This Book Is For

Clearly, this book is for programmers who want to create web applications 
(traditional
websites, RESTful APIs, or anything in between) using JavaScript, Node, and 
Express1
One    of the exciting aspects of Node development is that it has attracted a 
whole new
audience of programmers1 The accessibility and flexibility of JavaScript has 
attracted
self-taught programmers from all over the world1 At no time in the history of 
computer
science has programming been so accessible1 The number and quality of online 
resour‐
ces  for learning to program (and getting help when you get stuck) is truly 
astonishing
and inspiring1 So to those new (possibly self-taught) programmers, I welcome 
you1

Then, of course, there are the programmers like me, who have been around for a 
while1
Like many programmers of my era, I started off with assembler and BASIC, and 
went
through Pascal, C++, Perl, Java, PHP, Ruby, C, C#, and JavaScript1 At 
university, I was
exposed to more niche languages such as ML, LISP, and PROLOG1 Many of these lan‐
guages are near and dear to my heart, but in none of these languages do I see 
so much
promise as I do in JavaScript1 So I am also writing this book for programmers 
like myself,
who have a lot of experience, and perhaps a more philosophical outlook on 
specific
technologies1

No experience with Node is necessary, but you should have some experience with 
Java‐
Script1 If you1re new to programming, I recommend Codecademy1 If you1re an 
experi‐
enced  programmer,  I  recommend  Douglas  Crockford1s  JavaScript:  The  Good  
Parts
(O1Reilly)1 The examples in this book can be used with any system that Node 
works on
(which covers Windows, OS X, and Linux)1 The examples are geared toward command-
line (terminal) users, so you should have some familiarity with your system1s 
terminal1

Most important, this book is for programmers who are excited1 Excited about the 
future
of the Internet, and want to be part of it1 Excited about learning new things, 
new tech‐
niques, and new ways of looking at web development1 If, dear reader, you are 
not excited,
I   hope you will be by the time you reach the end of this book…1


How This Book Is Organized

Chapters 1 and 2 will introduce you to Node and Express and some of the tools 
you1ll
be using throughout the book1 In Chapters 3 and 4, you start using Express and 
build
the skeleton of a sample website that will be used as a running example 
throughout the
rest of the book1

Chapter 5 discusses testing and QA, and Chapter 6 covers some of Node1s more im‐
portant constructs and how they are extended and used by Express1 Chapter 7 
covers
templating (using Handlebars), which lays the foundation of building useful 
websites
with Express1 Chapters 8 and 9 cover cookies, sessions, and form handlers, 
rounding
out the things you need to know to build basic functional websites with 
Express1

Chapter 10 delves into “middleware,” a concept central to Connect (one of 
Express1s
major components)1 Chapter 11 explains how to use middleware to send email from
the server and discusses security and layout issues inherent to email1

Chapter 12 offers a preview into production concerns1 Even though, at this 
stage in the
book, you don1t have all the information you need to build a production-ready 
website,
thinking about production now can save you from major headaches in the future1

Chapter 13 is about persistence, with a focus on MongoDB (one of the leading 
document
databases)1

Chapter 14 gets into the details of routing with Express (how URLs are mapped to
content), and Chapter 15 takes a diversion into writing APIs with Express1 
Chapter 16
covers the details of serving static content, with a focus on maximizing 
performance1
Chapter 17 reviews the popular model-view-controller (MVC) paradigm, and how it
fits into Express1

Chapter 18 discusses security: how to build authentication and authorization 
into your
app (with a focus on using a third-party authentication provider), as well as 
how to run
your site over HTTPS1

Chapter 19 explains how to integrate with third-party services1 Examples used 
are Twit‐
ter, Google Maps, and Weather Underground1

Chapters 20 and 21 get your ready for the big day: your site launch1 They cover 
debug‐
ging, so you can root out any defects before launch, and the process of going 
live1
Chapter 22 talks about the next important (and oft-neglected) phase: 
maintenance1

The book concludes with Chapter 23, which points you to additional resources, 
should
you want to further your education about Node and Express, and where you can go 
to
get help1

xvi    |    Preface


Example Website

Starting in Chapter 3, a running example will be used throughout the book: the 
Mead‐
owlark Travel website1 Just having gotten back from a trip to Lisbon, I have 
travel on
my mind, so the example website I have chosen is for a fictional travel company 
in my
home state of Oregon (the Western Meadowlark is the state bird of Oregon)1 
Meadow‐
lark Travel allows travelers to connect to local “amateur tour guides,” and 
partners with
companies offering bike and scooter rentals and local tours1 In addition, it 
maintains a
database of local attractions, complete with history and location-aware 
services1

Like any pedagogical example, the Meadowlark Travel website is contrived, but 
it is an
example that covers many of the challenges facing real-world websites: 
third-party
component integration, geolocation, ecommerce, performance, and security1

As the focus on this book is backend infrastructure, the example website will 
not be
complete; it merely serves as a fictional example of a real-world website to 
provide depth
and context to the examples1 Presumably, you are working on your own website, 
and
you can use the Meadowlark Travel example as a template for it1

Conventions Used in This Book

The following typographical conventions are used in this book:

Italic

Indicates new terms, URLs, email addresses, filenames, and file extensions1

Constant width

Used for program listings, as well as within paragraphs to refer to program 
elements
such as variable or function names, databases, data types, environment 
variables,
statements, and keywords1

Constant width bold

Shows commands or other text that should be typed literally by the user1

Constant width italic

Shows text that should be replaced with user-supplied values or by values deter‐
mined by context1

This element signifies a tip or suggestion1


This element signifies a general note1

This element indicates a warning or caution1

Using Code Examples

Supplemental material (code examples, exercises, etc1) is available for 
download at

https://github1com/EthanRBrown/web-development-with-node-and-express1

This book is here to help you get your job done1 In general, if example code is 
offered
with this book, you may use it in your programs and documentation1 You do not 
need
to contact us for permission unless you1re reproducing a significant portion of 
the code1
For example, writing a program that uses several chunks of code from this book 
does
not require permission1 Selling or distributing a CD-ROM of examples from 
O1Reilly
books does require permission1 Answering a question by citing this book and 
quoting
example code does not require permission1 Incorporating a significant amount of 
ex‐
ample code from this book into your product1s documentation does require 
permission1

We appreciate, but do not require, attribution1 An attribution usually includes 
the title,
author, publisher, and ISBN1 For example: “Web Development with Node and Express
by Ethan Brown (O1Reilly)1 Copyright 2014 Ethan Brown, 978-1-491-94930-61”

If you feel your use of code examples falls outside fair use or the permission 
given above,
feel free to contact us at permissions@oreilly1com1

Safari® Books Online

Safari  Books  Online  is  an  on-demand  digital  library  that
delivers expert content in both book and video form from
the world1s leading authors in technology and business1

Technology professionals, software developers, web designers, and business and 
crea‐
tive professionals use Safari Books Online as their primary resource for 
research, prob‐
lem solving, learning, and certification training1

Safari Books Online offers a range of product mixes and pricing programs for 
organi‐
zations, government agencies, and individuals1 Subscribers have access to 
thousands of
books, training videos, and prepublication manuscripts in one fully searchable 
database


from publishers like O1Reilly Media, Prentice Hall Professional, Addison-Wesley 
Pro‐
fessional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco 
Press, John
Wiley   & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT
Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course 
Technol‐
ogy, and dozens more1 For more information about Safari Books Online, please 
visit us
online1

How to Contact Us

Please address comments and questions concerning this book to the publisher:

O1Reilly Media, Inc1

1005 Gravenstein Highway North
Sebastopol, CA 95472

800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)

707-829-0104 (fax)

We have a web page for this book, where we list errata, examples, and any 
additional
information1 You can access this page at http://bit1ly/web_dev_node_express1

To  comment  or  ask  technical  questions  about  this  book,  send  email  to 
 bookques
tions@oreilly1com1

For more information about our books, courses, conferences, and news, see our 
website
at http://www1oreilly1com1

Find us on Facebook: http://facebook1com/oreilly

Follow us on Twitter: http://twitter1com/oreillymedia

Watch us on YouTube: http://www1youtube1com/oreillymedia

Acknowledgments

So many people in my life have played a part in making this book a reality: it 
would not
have been possible without the influence of all the people who have touched my 
life and
made me who I am today1

I would like to start out by thanking everyone at Pop Art: not only has my time 
at Pop
Art given me a renewed passion for engineering, but I have learned so much from
everyone there, and without their support, this book would not exist1 I am 
grateful to
Steve Rosenbaum for creating an inspiring place to work, and to Del Olds for 
bringing
me on board, making me feel welcome, and being an honorable leader1 Thanks to 
Paul
Inman for his unwavering support and inspiring attitude toward engineering, and 
Tony
Alferez for his warm support and for helping me carve out time for writing 
without


impacting Pop Art1 Finally, thanks to all the great engineers I have worked 
with, who
keep me on my toes: John Skelton, Dylan Hallstrom, Greg Yung, Quinn Michael, and
CJ Stritzel1

Zach Mason, thank you for being an inspiration to me1 This book may be no The 
Lost
Books of the Odyssey, but it is mine, and I don1t know if I would have been so 
bold without
your example1

I owe everything to my family1 I couldn1t have wished for a better, more loving 
education
than the one they gave me, and I see their exceptional parenting reflected in 
my sister
too1

Many thanks to Simon St1 Laurent for giving me this opportunity, and to Brian 
Anderson
for his steady and encouraging editing1 Thanks to everyone at O1Reilly for 
their dedi‐
cation and passion1 Thanks to Jennifer Pierce, Mike Wilson, Ray Villalobos, and 
Eric
Elliot for their thorough and constructive technical reviews1

Katy Roberts and Hanna Nelson provided invaluable feedback and advice on my 
“over
the transom” proposal that made this book possible1 Thank you both so much! 
Thanks
to Chris Cowell-Shah for his excellent feedback on the QA chapter1

Lastly, thanks to my dear friends, without whom I surely would have gone 
insane1 Byron
Clayton, Mark Booth, Katy Roberts, and Sarah Lewis, you are the best group of 
friends
a      man could ask for1 And thanks to Vickey and Judy, just for being who 
they are1 I love
you all1


CHAPTER 1

Introducing Express

The JavaScript Revolution

Before I introduce the main subject of this book, it is important to provide a 
little back‐
ground and historical context, and that means talking about JavaScript and 
Node1

The age of JavaScript is truly upon us1 From its humble beginnings as a 
client-side
scripting language, not only has it become completely ubiquitous on the client 
side, but
its      use as a server-side language has finally taken off too, thanks to 
Node1

The promise of an all-JavaScript technology stack is clear: no more context 
switching!
No longer do you have to switch mental gears from JavaScript to PHP, C#, Ruby, 
or
Python (or any other server-side language)1 Furthermore, it empowers frontend 
engi‐
neers to make the jump to server-side programming1 This is not to say that 
server-side
programming is strictly about the language: there1s still a lot to learn1 With 
JavaScript,
though,        at least the language won1t be a barrier1

This book is for all those who see the promise of the JavaScript technology 
stack1 Perhaps
you are a frontend engineer looking to extend your experience into backend 
develop‐
ment1 Perhaps you1re an experienced backend developer like myself who is 
looking to
JavaScript as a viable alternative to entrenched server-side languages1

If you1ve been a software engineer for as long as I have, you have seen many 
languages,
frameworks, and APIs come into vogue1 Some have taken off, and some have faded 
into
obsolescence1 You probably take pride in your ability to rapidly learn new 
languages,
new  systems1 Every new language you come across feels a little more familiar: 
you
recognize a bit here from a language you learned in college, a bit there from 
that job
you     had a few years ago1 It feels good to have that kind of perspective, 
certainly, but it1s
also wearying1 Sometimes you want to just get something done, without having to 
learn
a whole new technology or dust off skills you haven1t used in months or years1


JavaScript may seem, at first, an unlikely champion1 I sympathize, believe me1 
If you
told me three years ago that I would not only come to think of JavaScript as my 
language
of choice, but also write a book about it, I would have told you you were 
crazy1 I had all
the usual prejudices against JavaScript: I thought it was a “toy” language1 
Something for
amateurs and dilettantes to mangle and abuse1 To be fair, JavaScript did lower 
the bar
for amateurs, and there was a lot of questionable JavaScript out there, which 
did not
help the language1s reputation1 To turn a popular saying on its head, “Hate the 
player,
not the game1”

It is unfortunate that people suffer this prejudice against JavaScript: it has 
prevented
people from discovering how powerful, flexible, and elegant the language is1 
Many peo‐
ple are just now starting to take JavaScript seriously, even though the 
language as we
know it now has been around since 1996 (although many of its more attractive 
features
were added in 2005)1

By picking up this book, you are probably free of that prejudice: either 
because, like me,
you have gotten past it, or because you never had it in the first place1 In 
either case, you
are fortunate, and I look forward to introducing you to Express, a technology 
made
possible by a delightful and surprising language1

In  2009,  years  after  people  had  started  to  realize  the  power  and  
expressiveness  of
JavaScript as a browser scripting language, Ryan Dahl saw JavaScript1s 
potential as a
server-side language, and Node was born1 This was a fertile time for Internet 
technology1
Ruby (and Ruby on Rails) took some great ideas from academic computer science,
combined them with some new ideas of its own, and showed the world a quicker way
to build websites and web applications1 Microsoft, in a valiant effort to 
become relevant
in the Internet age, did amazing things with 1NET and learned not only from 
Ruby and
JavaScript, but also from Java1s mistakes, while borrowing heavily from the 
halls of
academia1

It is an exciting time to be involved in Internet technology1 Everywhere, there 
are amaz‐
ing new ideas (or amazing old ideas revitalized)1 The spirit of innovation and 
excitement
is greater now than it has been in many years1

Introducing Express

The Express website describes Express as “a minimal and flexible node1js web 
applica‐
tion framework, providing a robust set of features for building single and 
multipage
and hybrid web applications1” What does that really mean, though? Let1s break 
that
description down:

Minimal

This is one of the most appealing aspects of Express1 Many times, framework de‐
velopers forget that usually “less is more1” The Express philosophy is to 
provide the
minimal layer between your brain and the server1 That doesn1t mean that it1s 
not


robust, or that it doesn1t have enough useful features1 It means that it gets 
in your
way less, allowing you full expression of your ideas, while at the same time 
providing
something useful1

Flexible

Another key aspect of the Express philosophy is that Express is extensible1 
Express
provides you a very minimal framework, and you can add in different parts of
Express functionality as needed, replacing whatever doesn1t meet your needs1 
This
is         a breath of fresh air1 So many frameworks give you everything, 
leaving you with
a bloated, mysterious, and complex project before you1ve even written a single 
line
of code1 Very often, the first task is to waste time carving off unneeded 
functionality,
or replacing the functionality that doesn1t meet requirements1 Express takes the
opposite approach, allowing you to add what you need when you need it1

Web application framework

Here1s where semantics starts to get tricky1 What1s a web application? Does that
mean you can1t build a website or web pages with Express? No, a website is a web
application, and a web page is a web application1 But a web application can be 
more:
it        can provide functionality to other web applications (among other 
things)1 In
general, “app” is used to signify something that has functionality: it1s not 
just a static
collection of content (though that is a very simple example of a web app)1 While
there      is currently a distinction between an “app” (something that runs 
natively on
your device) and a “web page” (something that is served to your device over the
network), that distinction is getting blurrier, thanks to projects like 
PhoneGap, as
well      as Microsoft1s move to allow HTML5 applications on the desktop, as if 
they
were native applications1 It1s easy to imagine that in a few years, there won1t 
be a
distinction between an app and a website1

Single-page web applications

Single-page web applications are a relatively new idea1 Instead of a website 
requiring
a network request every time the user navigates to a different page, a 
single-page
web application downloads the entire site (or a good chunk of it) to the 
client1s
browser1 After that initial download, navigation is faster because there is 
little or no
communication with the server1 Single-page application development is 
facilitated
by                               the use of popular frameworks such as Angular 
or Ember, which Express is happy
to serve up1

Multipage and hybrid web applications

Multipage web applications are a more traditional approach to websites1 Each 
page
on a website is provided by a separate request to the server1 Just because this 
ap‐
proach is more traditional does not mean it is not without merit or that 
single-page
applications are somehow better1 There are simply more options now, and you can
decide what parts of your content should be delivered as a single-page app, and


what parts should be delivered via individual requests1 “Hybrid” describes 
sites that
utilize both of these approaches1

If you1re still feeling confused about what Express actually is, don1t worry: 
sometimes
it1s much easier to just start using something to understand what it is, and 
this book will
get you started building web applications with Express1

A Brief History of Express

Express1s creator, TJ Holowaychuk, describes Express as a web framework 
inspired by
Sinatra, which is a web framework based on Ruby1 It is no surprise that Express 
borrows
from a framework built on Ruby: Ruby spawned a wealth of great approaches to web
development,  aimed  at  making  web  development  faster,  more  efficient,  
and  more
maintainable1

As much as Express was inspired by Sinatra, it is also deeply intertwined with 
Connect,
a “plugin” library for Node1 Connect coined the term “middleware” to describe 
pluggable
Node modules that can handle web requests to varying degrees1 Up until version 
410,
Express bundled Connect; in version 410, Connect (and all middleware except 
static)
was removed to allow these middleware to be updated independently1

Express underwent a fairly substantial rewrite between 21x and 310,
then again between 31x and 4101 This book will focus on version 4101

Upgrading to Express 410

If you already have some experience with Express 310, you1ll be happy to learn 
that
upgrading to Express 410 is pretty painless1 If you1re new to Express, you can 
skip this
section1 Here are the high points for those with Express 310 experience:

•  Connect has been removed from Express, so with the exception of the static
middleware, you will need to install the appropriate packages (namely, connect)1
At the same time, Connect has been moving some of its middleware into their own
packages, so you might have to do some searching on npm to figure out where your
middleware went1

•  body-parser is now its own package, which no longer includes the multipart
middleware, closing a major security hole1 It1s now safe to use the body-parser
middleware1

•  You no longer have to link the Express router into your application1 So you 
should
remove app1use(app1router) from your existing Express 310 apps1


•  app1configure was removed; simply replace calls to this method by examining

app1get(env) (using either a switch statement or if statements)1

For more details, see the official migration guide1

Express is an open source project and continues to be primarily developed and 
main‐
tained by TJ Holowaychuk1

Node: A New Kind of Web Server

In a way, Node has a lot in common with other popular web servers, like 
Microsoft1s
Internet Information Services (IIS) or Apache1 What is more interesting, 
though, is how
it differs, so let1s start there1

Much  like  Express,  Node1s  approach  to  webservers  is  very  minimal1  
Unlike  IIS  or
Apache, which a person can spend many years mastering, Node is very easy to set 
up
and configure1 That is not to say that tuning Node servers for maximum 
performance
in a production setting is a trivial matter: it1s just that the configuration 
options are
simpler and more straightforward1

Another major difference between Node and more traditional web servers is that 
Node
is single threaded1 At first blush, this may seem like a step backward1 As it 
turns out, it
is a stroke of genius1 Single threading vastly simplifies the business of 
writing web apps,
and if you need the performance of a multithreaded app, you can simply spin up 
more
instances of Node, and you will effectively have the performance benefits of 
multi‐
threading1 The astute reader is probably thinking this sounds like smoke and 
mirrors1
After      all, isn1t multithreading through server parallelism (as opposed to 
app parallelism)
simply moving the complexity around, not eliminating it? Perhaps, but in my 
experi‐
ence, it has moved the complexity to exactly where it should be1 Furthermore, 
with the
growing popularity of cloud computing and treating servers as generic 
commodities,
this approach makes a lot more sense1 IIS and Apache are powerful indeed, and 
they
are designed to squeeze the very last drop of performance out of today1s 
powerful hard‐
ware1 That comes at a cost, though: they require considerable expertise to set 
up and
tune to achieve that performance1

In terms of the way apps are written, Node apps have more in common with PHP or
Ruby apps than 1NET or Java apps1 While the JavaScript engine that Node uses 
(Google1s
V8) does compile JavaScript to native machine code (much like C or C++), it 
does so
transparently,1  so from the user1s perspective, it behaves like a purely 
interpreted lan‐
guage1              Not having a separate compile step reduces maintenance and 
deployment hassles:
all you have to do is update a JavaScript file, and your changes will 
automatically be
available1

11  Often called “Just in Time” (JIT) compilation1


Another compelling benefit of Node apps is that Node is incredibly platform 
inde‐
pendent1 It1s not the first or only platform-independent server technology, but 
platform
independence is really more of a spectrum than a binary proposition1 For 
example, you
can        run 1NET apps on a Linux server thanks to Mono, but it1s a painful 
endeavor1
Likewise, you can run PHP apps on a Windows server, but it is not generally as 
easy to
set        up as it is on a Linux machine1 Node, on the other hand, is a snap 
to set up on all the
major operating systems (Windows, OS X, and Linux) and enables easy 
collaboration1
Among website design teams, a mix of PCs and Macs is quite common1 Certain plat‐
forms, like 1NET, introduce challenges for frontend developers and designers, 
who often
use Macs, which has a huge impact on collaboration and efficiency1 The idea of 
being
able to spin up a functioning server on any operating system in a matter of 
minutes (or
even seconds!) is a dream come true1

The Node Ecosystem

Node, of course, lies at the heart of the stack1 It1s the software that enables 
JavaScript to
run on the server, uncoupled from a browser, which in turn allows frameworks 
written
in JavaScript (like Express) to be used1 Another important component is the 
database,
which will be covered in more depth in Chapter 131 All but the simplest of web 
apps
will need a database, and there are databases that are more at home in the Node 
eco‐
system than others1

It is unsurprising that database interfaces are available for all the major 
relational da‐
tabases (MySQL, MariaDB, PostgreSQL, Oracle, SQL Server): it would be foolish to
neglect those established behemoths1 However, the advent of Node development has
revitalized a new approach to database storage: the so-called “NoSQL” 
databases1 It1s not
always helpful to define something as what it1s not, so we1ll add that these 
NoSQL da‐
tabases might be more properly called “document databases” or “key/value pair 
data‐
bases1” They provide a conceptually simpler approach to data storage1 There are 
many,
but MongoDB is one of the frontrunners, and the one we will be using in this 
book1

Because building a functional website depends on multiple pieces of technology, 
acro‐
nyms have been spawned to describe the “stack” that a website is built on1 For 
example,
the combination of Linux, Apache, MySQL, and PHP is referred to as the LAMP 
stack1
Valeri Karpov, an engineer at MongoDB, coined the acronym MEAN: Mongo, Express,
Angular, and Node1 While it1s certainly catchy, it is limiting: there are so 
many choices
for databases and application frameworks that “MEAN” doesn1t capture the 
diversity of
the ecosystem (it also leaves out what I believe is an important component: 
templating
engines)1

Coining an inclusive acronym is an interesting exercise1 The indispensable 
component,
of course, is Node1 While there are other server-side JavaScript containers, 
Node is
emerging as the dominant one1 Express, also, is not the only web app framework 
avail‐
able, though it is close to Node in its dominance1 The two other components 
that are


usually essential for web app development are a database server and a 
templating engine
(a templating engine provides what PHP, JSP, or Razor provides naturally: the 
ability to
seamlessly combine code and markup output)1 For these last two components, there
aren1t     as many clear frontrunners, and this is where I believe it1s a 
disservice to be re‐
strictive1

What ties all these technologies together is JavaScript, so in an effort to be 
inclusive, I
will be referring to the “JavaScript stack1” For the purposes of this book, 
that means
Node, Express, and MongoDB1

Licensing

When developing Node applications, you may find yourself having to pay more 
atten‐
tion to licensing than you ever have before (I certainly have)1 One of the 
beauties of the
Node ecosystem is the vast array of packages available to you1 However, each of 
those
packages carries its own licensing, and worse, each package may depend on other 
pack‐
ages, meaning that understanding the licensing of the various parts of the app 
you1ve
written can be tricky1

However, there is some good news1 One of the most popular licenses for Node 
packages
is the MIT license, which is painlessly permissive, allowing you to do almost 
anything
you want, including use the package in closed source software1 However, you 
shouldn1t
just assume every package you use is MIT licensed1

There are several packages available in npm that will try to figure out
the  licenses  of  each  dependency  in  your  project1  Search  npm  for
license-sniffer or license-spelunker1

While MIT is the most common license you will encounter, you may also see the 
fol‐
lowing licenses:

GNU General Public License (GPL)

The GPL is a very popular open source license that has been cleverly crafted to 
keep
software free1 That means if you use GPL-licensed code in your project, your 
project
must also be GPL licensed1 Naturally, this means your project can1t be closed 
source1

Apache 210

This license, like MIT, allows you to use a different license for your project, 
includ‐
ing a closed source license1 You must, however, include notice of components 
that
use the Apache 210 license1


Berkeley Software Distribution (BSD)

Similar to Apache, this license allows you to use whatever license you wish for 
your
project, as long as you include notice of the BSD-licensed components1

Software  is  sometimes  dual  licensed  (licensed  under  two  different
licenses)1 A very common reason for doing this is to allow the soft‐
ware   to be used in both GPL projects and projects with more per‐
missive licensing1 (For a component to be used in GPL software, the
component must be GPL licensed1) This is a licensing scheme I often
employ with my own projects: dual licensing with GPL and MIT1

Lastly, if you find yourself writing your own packages, you should be a good 
citizen and
pick a license for your package, and document it correctly1 There is nothing 
more frus‐
trating to a developer than using someone1s package and having to dig around in 
the
source to determine the licensing or, worse, find that it isn1t licensed at 
all1


CHAPTER 2

Getting Started with Node

If you don1t have any experience with Node, this chapter is for you1 
Understanding
Express and its usefulness requires a basic understanding of Node1 If you 
already have
experience building web apps with Node, feel free to skip this chapter1 In this 
chapter,
we        will be building a very minimal web server with Node; in the next 
chapter, we will
see how to do the same thing with Express1

Getting Node

Getting Node installed on your system couldn1t be easier1 The Node team has 
gone to
great lengths to make sure the installation process is simple and 
straightforward on all
major platforms1

The installation is so simple, as a matter of fact, that it can be summed up in 
three simple
steps:

11  Go to the Node home page1

21  Click the big green button that says INSTALL1

31  Follow instructions1

For Windows and OS X, an installer will be downloaded that walks you through the
process1 For Linux, you will probably be up and running more quickly if you use 
a
package manager1

If you1re a Linux user and you do want to use a package manager,
make sure you follow the instructions in the aforementioned web
page1  Many  Linux  distributions  will  install  an  extremely  old  ver‐
sion of Node if you don1t add the appropriate package repository1


You can also download a standalone installer, which can be helpful if you are 
distributing
Node to your organization1

If you have trouble building Node, or for some reason you would like to build 
Node
from scratch, please refer to the official installation instructions1

Using the Terminal

I1m an unrepentant fan of the power and productivity of using a terminal (also 
called a
“console” or “command prompt”)1 Throughout this book, all examples will assume
you1re using a terminal1 If you1re not friends with your terminal, I highly 
recommend
you spend some time familiarizing yourself with your terminal of choice1 Many 
of the
utilities in this book have corresponding GUI interfaces, so if you1re dead set 
against
using a terminal, you have options, but you will have to find your own way1

If you1re on OS X or Linux, you have a wealth of venerable shells (the terminal 
command
interpreter) to choose from1 The most popular by far is bash, though zsh has 
its adher‐
ents1      The main reason I gravitate toward bash (other than long 
familiarity) is ubiquity1
Sit down in front of any Unix-based computer, and 99% of the time, the default 
shell
will be bash1

If you1re a Windows user, things aren1t quite so rosy1 Microsoft has never been 
partic‐
ularly interested in providing a pleasant terminal experience, so you1ll have 
to do a little
more work1 Git helpfully includes a “Git bash” shell, which provides a 
Unix-like terminal
experience (it only has a small subset of the normally available Unix 
command-line
utilities, but it1s a useful subset)1 While Git bash provides you with a 
minimal bash shell,
it1s   still using the built-in Windows console application, which leads to an 
exercise in
frustration (even simple functionaity like resizing a console window, selecting 
text, cut‐
ting,     and pasting is unintuitive and awkward)1 For this reason, I recommend 
installing
a more sophisticated terminal such as Console2 or ConEmu1 For Windows power 
users

—especially for 1NET developers or for hardcore Windows systems or network 
admin‐
istrators—there is another option: Microsoft1s own PowerShell1 PowerShell lives 
up to
its name: people do remarkable things with it, and a skilled PowerShell user 
could give
a Unix command-line guru a run for their money1 However, if you move between OS
X/Linux and Windows, I still recommend sticking with Git bash for the 
consistency it
provides1

Another option, if you1re a Windows user, is virtualization1 With the power and 
archi‐
tecture of modern computers, the performance of virtual machines (VMs) is 
practically
indistinguishable from actual machines1 I1ve had great luck with Oracle1s free 
Virtual‐
Box,                   and Windows 8 offers VM support built in1 With 
cloud-based file storage, such as
Dropbox, and the easy bridging of VM storage to host storage, virtualizing is 
looking
more attractive all the time1 Instead of using Git bash as a bandage on 
Windows1s
lackluster console support, consider using a Linux VM for development1 If you 
find the


UI isn1t as smooth as you would like, you could use a terminal application, 
such as
PuTTY, which is what I often do1

Finally, no matter what sytem you1re on, there1s the excellent Codio1 Codio is 
a website
that will spin up a new Linux instance for every project you have and provide 
an IDE
and command line, with Node already installed1 It1s extremely easy to use and 
is a great
way to get started very quickly with Node1

When you specify the -g (global) option when installing npm pack‐
ages,  they  are  installed  in  a  subdirectory  of  your  Windows  home
directory1 I1ve found that a lot of these packages don1t perform well if
there   are spaces in your username (my username used to be “Ethan
Brown,” and now it1s “ethan1brown”)1 For your sanity, I recommend
choosing a Windows username without a space in it1 If you already
have such a username, it1s advisable to create a new user, and then
transfer your files over to the new account: trying to rename your
Windows home directory is possible but fraught with danger1

Once you1ve settled on a shell that makes you happy, I recommend you spend some 
time
getting to know the basics1 There are many wonderful tutorials on the Internet, 
and
you1ll save yourself a lot of headaches later on by learning a little now1 At 
minimum,
you should know how to navigate directories; copy, move, and delete files; and 
break
out of a command-line program (usually Ctrl-C)1 If you want to become a terminal
ninja, I encourage you to learn how to search for text in files, search for 
files and direc‐
tories, chain commands together (the old “Unix philosophy”), and redirect 
output1

On many Unix-like systems, Ctrl-S has a special meaning: it will
“freeze” the terminal (this was once used to pause output quickly
scrolling past)1 Since this is such a common shortcut for Save, it1s
very  easy  to  unthinkingly  press,  which  leads  to  a  very  confusing
situation for most people (this happens to me more often than I care
to admit)1 To unfreeze the terminal, simply hit Ctrl-Q1 So if you1re
ever confounded by a terminal that seems to have suddenly frozen,
try pressing Ctrl-Q and see if it releases it1

Editors

Few topics inspire such heated debate among programmers as the choice of 
editors, and
for good reason: the editor is your primary tool1 My editor of choice is vi1 
(or an editor
that has a vi mode)1 vi isn1t for everyone (my coworkers constantly roll their 
eyes at me

11  These days, vi is essentially synonymous with vim (vi improved)1 On most 
systems, vi is aliased to vim, but
I usually type vim to make sure I1m using vim1


when I tell them how easy it would be to do what they1re doing in vi), but 
finding a
powerful editor and learning to use it will significantly increase your 
productivity and,
dare I say it, enjoyment1 One of the reasons I particularly like vi (though 
hardly the most
important reason) is that like bash, it is ubiquitous1 If you have access to a 
Unix system
(Cygwin included), vi is there for you1 Many popular editors (even Microsoft 
Visual
Studio!) have a vi mode1 Once you get used to it, it1s hard to imagine using 
anything
else1 vi is a hard road at first, but the payoff is worth it1

If, like me, you see the value in being familiar with an editor that1s 
available anywhere,
your other option is Emacs1 Emacs and I have never quite gotten on (and usually 
you1re
either an Emacs person or a vi person), but I absolutely respect the power and 
flexibility
that Emacs provides1 If vi1s modal editing approach isn1t for you, I would 
encourage you
to look into Emacs1

While knowing a console editor (like vi or Emacs) can come in incredibly handy, 
you
may still want a more modern editor1 Some of my frontend colleagues swear by 
Coda,
and I trust their opinion1 Unfortunately, Coda is available only on OS X1 
Sublime Text
is   a modern and powerful editor that also has an excellent vi mode, and it1s 
available on
Windows, Linux, and OS X1

On Windows, there are some fine free options out there1 TextPad and Notepad++ 
both
have their supporters1 They1re both capable editors, and you can1t beat the 
price1 If you1re
a Windows user, don1t overlook Visual Studio as a JavaScript editor: it1s 
remarkably
capable, and has one of the best JavaScript autocomplete engines of any editor1 
You can
download Visual Studio Express from Microsoft for free1

npm

npm is the ubiquitous package manager for Node packages (and is how we1ll get 
and
install Express)1 In the wry tradition of PHP, GNU, WINE, and others, “npm” is 
not an
acronym (which is why it isn1t capitalized); rather, it is a recursive 
abbreviation for “npm
is       not an acronym1”

Broadly speaking, a package manager1s two primary responsibilities are 
installing pack‐
ages and manging dependencies1 npm is a fast, capable, and painless package 
manager,
which I feel is in large part responsible for the rapid growth and diversity of 
the Node
ecosystem1

npm is installed when you install Node, so if you followed the steps listed 
earlier, you1ve
already got it1 So let1s get to work!


The primary command you1ll be using with npm (unsurprisingly), is install1 For 
ex‐
ample, to install Grunt (a popular JavaScript task runner), you would issue the 
following
command (on the console):

npm install -g grunt-cli

The -g flag tells npm to install the package globally, meaning it1s available 
globally on
the system1 This distinction will become clearer when we cover the package1json 
files1
For now, the rule of thumb is that JavaScript utilities (like Grunt) will 
generally be
installed globally, whereas packages that are specific to your web app or 
project will not1

Unlike languages like Python—which underwent a major language
change from 210 to 310, necessitating a way to easily switch between
different environments—the Node platform is new enough that it is
likely that you should always be running the latest version of Node1
However, if you do find yourself needing to support multiple ver‐
sion       of  Node,  there  is  a  project,  nvm,  that  allows  you  to  
switch
environments1

A Simple Web Server with Node

If you1ve ever built a static HTML website before, or are coming from a PHP or 
ASP
background, you1re probably used to the idea of the web server (Apache or IIS, 
for
example) serving your static files so that a browser can view them over the 
network1 For
example, if you create the file about1html, and put it in the proper directory, 
you can
then navigate to http://localhost/about1html1 Depending on your web server 
configu‐
ration, you might even be able to omit the 1html, but the relationship between 
URL and
filename is clear: the web server simply knows where the file is on the 
computer, and
serves it to the browser1

localhost, as the name implies, refers to the computer you1re on1 This
is a common alias for the IPv4 loopback address 127101011, or the IPv6
loopback address ::11 You will often see 127101011 used instead, but I
will       be using localhost in this book1 If you1re using a remote computer
(using SSH, for example), keep in mind that browsing to localhost will
not connect to that computer1

Node offers a different paradigm than that of a traditional web server: the app 
that you
write is the web server1 Node simply provides the framework for you to build a 
web
server1

“But I don1t want to write a web server,” you might be saying! It1s a natural 
response: you
want to be writing an app, not a web server1 However, Node makes the business 
of writing


this web server a simple affair (just a few lines, even) and the control you 
gain over your
application in return is more than worth it1

So let1s get to it1 You1ve installed Node, you1ve made friends with the 
terminal, and now
you1re ready to go1

Hello World

I1ve always found it unfortunate that the canonical introductory programming 
example
is the uninspired message “Hello World1” However, it seems almost sacrilegious 
at this
point to fly in the face of such ponderous tradition, so we1ll start there, and 
then move
on  to something more interesting1

In your favorite editor, create a file called helloWorld1js:

var http = require('http');

http1createServer(function(req,res){

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('Hello world!');

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

Make  sure  you  are  in  the  same  directory  as  helloWorld1js,  and  type  
node hello
World1js1 Then open up a browser and navigate to http://localhost:3000, and 
voil! Your
first web server1 This particular one doesn1t serve HTML; rather, it just 
transmits the
message “Hello world!” in plaintext to your browser1 If you want, you can 
experiment
with sending HTML instead: just change text/plain to text/html and change 'Hello
world!' to a string containing valid HTML1 I didn1t demonstrate that, because I 
try to
avoid writing HTML inside JavaScript for reasons that will be discussed in more 
detail
in Chapter 71

Event-Driven Programming

The core philosophy behind Node is that of event-driven programming1 What that 
means
for you, the programmer, is that you have to understand what events are 
available to
you and how to respond to them1 Many people are introduced to event-driven pro‐
gramming by implementing a user interface: the user clicks on something, and you
handle  the “click event1” It1s a good metaphor, because it1s understood that 
the program‐
mer has no control over when, or if, the user is going to click something, so 
event-driven
programming is really quite intuitive1 It can be a little harder to make the 
conceptual
leap               to responding to events on the server, but the principle is 
the same1

In the previous code example, the event is implicit: the event that1s being 
handled is an
HTTP request1 The http1createServer method takes a function as an argument; 
that


function will be invoked every time an HTTP request is made1 Our simple program 
just
sets the content type to plaintext and sends the string “Hello world!”

Routing

Routing refers to the mechanism for serving the client the content it has asked 
for1 For
web-based client/server applications, the client specifies the desired content 
in the URL;
specifically, the path and querystring (the parts of a URL will be discussed in 
more detail
in Chapter 6)1

Let1s expand our “Hello world!” example to do something more interesting1 Let1s 
serve
a really minimal website consisting of a home page, an About page, and a Not 
Found
page1 For now, we1ll stick with our previous example and just serve plaintext 
instead of
HTML:

var http = require('http');

http1createServer(function(req,res){

// normalize url by removing querystring, optional

// trailing slash, and making it lowercase

var path = req1url1replace(/\/?(?:\?1*)?$/, '')1toLowerCase();

switch(path) {

case '':

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('Homepage');

break;
case '/about':

res1writeHead(200, { 'Content-Type': 'text/plain' });
res1end('About');

break;
default:

res1writeHead(404, { 'Content-Type': 'text/plain' });
res1end('Not Found');

break;

}

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

If you run this, you1ll find you can now browse to the home page 
(http://localhost:
3000) and the About page (http://localhost:3000/about)1 Any querystrings will 
be ig‐
nored (so http://localhost:3000/?foo=bar will serve the home page), and any 
other URL
(http://localhost:3000/foo) will serve the Not Found page1

Serving Static Resources

Now that we1ve got some simple routing working, let1s serve some real HTML and a
logo image1 These are called “static resources” because they don1t change (as 
opposed
to, for example, a stock ticker: every time you reload the page, the stock 
prices change)1


Serving static resources with Node is suitable for developent and small
projects, but for larger projects, you will probably want to use a proxy
server such as Nginx or a CDN to serve static resources1 See Chap‐
ter  16 for more information1

If you1ve worked with Apache or IIS, you1re probably used to just creating an 
HTML
file, navigating to it, and having it delivered to the browser automatically1 
Node doesn1t
work like that: we1re going to have to do the work of opening the file, reading 
it, and
then sending its contents along to the browser1 So let1s create a directory in 
our project
called public (why we don1t call it static will become evident in the next 
chapter)1 In that
directory,  we1ll  create  home1html,  about1html,  notfound1html,  a  
subdirectory  called
img,   and an image called img/logo1jpg1 I1ll leave that up to you: if you1re 
reading this
book, you probably know how to write an HTML file and find an image1 In your 
HTML
files, reference the logo thusly: <img href="/img/logo1jpg" alt="logo">1

Now modify helloWorld1js:

var http = require('http'),
fs = require('fs');

function serveStaticFile(res, path, contentType, responseCode) {

if(!responseCode) responseCode = 200;

fs1readFile(  dirname + path, function(err,data) {

if(err) {

res1writeHead(500, { 'Content-Type': 'text/plain' });
res1end('500 - Internal Error');

} else {

res1writeHead(responseCode,

{ 'Content-Type': contentType });
res1end(data);

}

});

}

http1createServer(function(req,res){

// normalize url by removing querystring, optional

// trailing slash, and making lowercase

var path = req1url1replace(/\/?(?:\?1*)?$/, '')

1toLowerCase();

switch(path) {

case '':

serveStaticFile(res, '/public/home1html', 'text/html');

break;
case '/about':

serveStaticFile(res, '/public/about1html', 'text/html');

break;

case '/img/logo1jpg':

serveStaticFile(res, '/public/img/logo1jpg',


'image/jpeg');

break;
default:

serveStaticFile(res, '/public/4041html', 'text/html',
404);

break;

}

})1listen(3000);

console1log('Server started on localhost:3000; press Ctrl-C to terminate1   ');

In this example, we1re being pretty unimaginative with our routing1
If you navigate to http://localhost:3000/about, the public/about1html
file is served1 You could change the route to be anything you want,
and change the file to be anything you want1 For example, if you had
a different About page for each day of the week, you could have files
public/about_mon1html, public/about_tue1html, and so on, and pro‐
vide logic in your routing to serve the appropriate page when the user
navigates to http://localhost:3000/about1

Note we1ve created a helper function, serveStaticFile, that1s doing the bulk of 
the
work1 fs1readFile is an asynchronous method for reading files1 There is a 
synchronous
version of that function, fs1readFileSync, but the sooner you start thinking 
asyn‐
chronously, the better1 The function is simple: it calls fs1readFile to read 
the contents
of             the specified file1 fs1readFile executes the callback function 
when the file has been
read; if the file didn1t exist or there were permissions issues reading the 
file, the err
variable is set, and the function returns an HTTP status code of 500 indicating 
a server
error1   If the file is read successfully, the file is sent to the client with 
the specified response
code and content type1 Response codes will be discussed in more detail in 
Chapter 61

  dirname will resolve to the directory the executing script resides in1
So if your script resides in /home/sites/app1js,     dirname will resolve
to  /home/sites1  It1s  a  good  idea  to  use  this  handy  global  whenever
possible1 Failing to do so can cause hard-to-diagnose errors if you run
your app from a different directory1

Onward to Express

So far, Node probably doesn1t seem that impressive to you1 We1ve basically 
replicated
what Apache or IIS do for you automatically, but now you have some insight into 
how
Node does things and how much control you have1 We haven1t done anything 
particu‐
larly impressive, but you can see how we could use this as a jumping-off point 
to do
more sophisticated things1 If we continued down this road, writing more and 
more


sophisticated Node applications, you might very well end up with something that 
re‐
sembles Express…1

Fortunately, we don1t have to: Express already exists, and it saves you from 
implementing
a lot of time-consuming infrastructure1 So now that we1ve gotten a little Node 
experience
under our belt, we1re ready to jump into learning Express1


CHAPTER 3

Saving Time with Express

In Chapter 2, you learned how to create a simple web server using only Node1 In 
this
chapter, we will recreate that server using Express1 This will provide a 
jumping-off point
for   the rest of the content of this book and introduce you to the basics of 
Express1

Scaffolding

Scaffolding is not a new idea, but many people (myself included) were 
introduced to
the concept by Ruby1 The idea is simple: most projects require a certain amount 
of so-
called “boilerplate” code, and who wants to recreate that code every time you 
begin a
new project? A simple way is to create a rough skeleton of a project, and every 
time you
need a new project, you just copy this skeleton, or template1

Ruby on Rails took this concept one step further by providing a program that 
would
automatically generate scaffolding for you1 The advantage of this approach is 
that it
could generate a more sophisticated framework than just selecting from a 
collection of
templates1

Express has taken a page from Ruby on Rails and provided a utility to generate 
scaf‐
folding to start your Express project1

While the Express scaffolding utility is useful, it currently doesn1t generate 
the frame‐
work I will be recommending in this book1 In particular, it doesn1t provide 
support for
my templating language of choice (Handlebars), and it also doesn1t follow some 
of the
naming conventions I prefer (though that is easy enough to fix)1

While we won1t be using the scaffolding utility, I encourage you to take a look 
at it once
you1ve finished the book: by then you1ll be armed with everything you need to 
know to
evaluate whether the scaffolding it generates is useful for you1

Boilerplate is also useful for the actual HTML that will be delivered to the 
client1 I
recommend the excellent HTML5 Boilerplate1 It generates a great blank slate for 
an

19


HTML5 website1 Recently, HTML5 Boilerplate has added the ability to generate a 
cus‐
tom build1 One of the custom build options includes Twitter Bootstrap, a 
frontend
framework I highly recommend1 We1ll be using a Bootstrap-based custom build in
Chapter    7 to provide a responsive, modern HTML5 website1

The Meadowlark Travel Website

Throughout  this  book,  we1ll  be  using  a  running  example:  a  fictional  
website  for
Meadowlark Travel, a company offering services for people visiting the great 
state of
Oregon1 If you1re more interested in creating a REST application, have no fear: 
the
Meadowlark Travel website will expose REST services in addition to serving a 
functional
website1

Initial Steps

Start by creating a new directory for your project: this will be the root 
directory for your
project1 In this book, whenever we refer to the “project directory,” “app 
directory,” or
“project root,” we1re referring to this directory1

You1ll probably want to keep your web app files separate from all the
other files that usually accompany a project, such as meeting notes,
documentation,  etc1  For  that  reason,  I  recommend  making  your
project           root a subdirectory of your project directory1 For example, 
for
the Meadowlark Travel website, I might keep the project in ~/projects/
meadowlark, and the project root in ~/projects/meadowlark/site1

npm manages project dependencies—as well as metadata about the project—in a file
called package1json1 The easiest way to create this file is to run npm init: it 
will ask you
a series of questions and generate a package1json file to get you started (for 
the “entry
point” question, use meadowlark1js or the name of your project)1

Every time you run npm, you1ll get warnings unless you provide a
repository URL in package1json, and a nonempty README1md file1
The metadata in the package1json file is really only necessary if you1re
planning on publishing to the npm repository, but squelching npm
warnings is worth the small effort1

The first step will be installing Express1 Run the following npm command:

npm install --save express

Running npm install will install the named package(s) in the node_modules 
directo‐
ry1  If  you  specify  the  --save flag,  it  will  update  the  package1json  
file1  Since  the


node_modules dirctory can be regenerated at any time with npm, we will not save 
it in
our repository1 To ensure we don1t accidentally add it to our repository, we 
create a file
called 1gitignore:

# ignore packages installed by npm
node_modules

# put any other files you don't want to check in here,
# such as 1DS_Store (OSX), *1bak, etc1

Now create a file called meadowlark1js1 This will be our project1s entry point1 
Throughout
the book, we will simply be referring to this file as the “app file”:

var express = require('express');

var app = express();

app1set('port', process1env1PORT || 3000);

// custom 404 page

app1use(function(req, res){
res1type('text/plain');
res1status(404);
res1send('404 - Not Found');

});

// custom 500 page

app1use(function(err, req, res, next){
console1error(err1stack);
res1type('text/plain');
res1status(500);

res1send('500 - Server Error');

});

app1listen(app1get('port'), function(){

console1log( 'Express started on http://localhost:' +
app1get('port') + '; press Ctrl-C to terminate1' );

});

Many tutorials, as well as the Express scaffolding generator, encour‐
age you to name your primary file app1js (or sometimes index1js or
server1js)1 Unless you1re using a hosting service or deployment sys‐
tem   that requires your main application file to have a specific name,
I don1t feel there1s a compelling reason to do this, and I prefer to name
the primary file after the project1 Anyone who1s ever stared at a bunch
of editor tabs that all say “index1html” will immediately see the wis‐
dom of this1 npm init will default to index1js; if you use a different
name for your application file, make sure to update the main proper‐
ty   in package1json1


You  now  have  a  minimal  Express  server1  You  can  start  the  server  
(node meadow
lark1js), and navigate to http://localhost:30001 The result will be 
disappointing: you
haven1t provided Express with any routes, so it will simply give you a generic 
404 page
indicating that the page doesn1t exist1

Note how we specify the port that we want our application to run on:
app1set(port,  process1env1PORT  ||  3000)1  This  allows  us  to
override the port by setting an environment value before you start the
server1  If  your  app  isn1t  running  on  port  3000  when  you  run  this
example, check to see if your PORT environment variable is set1

I  highly  recommend  getting  a  browser  plugin  that  shows  you  the
status code of the HTTP request as well as any redirects that took
place1 It will make it easier to spot redirect issues in your code, or
incorrect status codes, which are often overlooked1 For Chrome, Ayi‐
ma1s Redirect Path works wonderfully1 In most browsers, you can see
the status code in the Network section of the developer tools1

Let1s add some routes for the home page and an About page1 Before the 404 
handler,
we1ll add two new routes:

app1get('/', function(req, res){
res1type('text/plain');
res1send('Meadowlark Travel');

});

app1get('/about', function(req, res){
res1type('text/plain');
res1send('About Meadowlark Travel');

});

// custom 404 page

app1use(function(req, res, next){
res1type('text/plain');
res1status(404);
res1send('404 - Not Found');

});

app1get is the method by which we1re adding routes1 In the Express 
documentation,
you will see app1VERB1 This doesn1t mean that there1s literally a method called 
VERB; it1s
just a placeholder for your (lowercased) HTTP verbs (“get” and “post” being the 
most
common)1 This method takes two parameters: a path and a function1

The path is what defines the route1 Note that app1VERB does the heavy lifting 
for you:
by default, it doesn1t care about the case or trailing slash, and it doesn1t 
consider the
querystring when performing the match1 So the route for the About page will work
for    /about, /About, /about/, /about?foo=bar, /about/?foo=bar, etc1


The function you provide will get invoked when the route is matched1 The 
parameters
passed to that function are the request and response objects, which we1ll learn 
more
about in Chapter 61 For now, we1re just returning plaintext with a status code 
of 200
(Express defaults to a status code of 200—you don1t have to specify it 
explicitly)1

Instead of using Node1s low-level res1end, we1re switching to using Express1s 
extension,
res1send1 We are also replacing Node1s res1writeHead with res1set and res1sta
tus1 Express is also providing us a convenience method, res1type, which sets the
Content-Type header1 While it1s still possible to use res1writeHead and 
res1end, it isn1t
necessary    or recommended1

Note that our custom 404 and 500 pages must be handled slightly differently1 
Instead
of using app1get, it is using app1use1 app1use is the method by which Express 
adds
middleware1 We1ll be covering middleware in more depth in Chapter 10, but for 
now,
you        can think of this as a catch-all handler for anything that didn1t 
get matched by a
route1 This brings us to a very important point: in Express, the order in which 
routes and
middleware are added is significant1 If we put the 404 handler above the 
routes, the home
page     and About page would stop working: instead, those URLs would result in 
a 4041
Right now, our routes are pretty simple, but they also support wildcards, which 
can lead
to problems with ordering1 For example, what if we wanted to add subpages to 
About,
such as /about/contact and /about/directions? The following will not work as 
expected:

app1get('/about*',function(req,res){

// send content1111

})

app1get('/about/contact',function(req,res){

// send content1111

})

app1get('/about/directions',function(req,res){

// send content1111

})

In this example, the /about/contact and /about/directions handlers will never be
matched because the first handler uses a wildcard in its path: /about*1

Express can distinguish between the 404 and 500 handlers by the number of 
arguments
their callback functions take1 Error routes will be covered in depth in 
Chapters 10 and 121

Now you can start the server again, and see that there1s a functioning home 
page and
About page1

So far, we haven1t done anything that couldn1t be done just as easily without 
Express,
but already Express is providing us some functionality that isn1t immediately 
obvious1
Remember in the previous chapter how we had to normalize req1url to determine 
what
resource was being requested? We had to manually strip off the querystring and 
the
trailing slash, and convert to lowercase1 Express1s router is now handling 
those details


for us automatically1 While it may not seem like a large thing now, it1s only 
scratching
the surface of what Express1s router is capable of1

Views and Layouts

If you1re familiar with the “model-view-controller” paradigm, then the concept 
of a view
will be no stranger to you1 Essentially, a view is what gets delivered to the 
user1 In the
case of a website, that usually means HTML, though you could also deliver a PNG 
or a
PDF, or anything that can be rendered by the client1 For our purposes, we will 
consider
views to be HTML1

Where a view differs from a static resource (like an image or CSS file) is that 
a view
doesn1t necessarily have to be static: the HTML can be constructed on the fly 
to provide
a customized page for each request1

Express supports many different view engines that provide different levels of 
abstrac‐
tion1 Express gives some preference to a view engine called Jade (which is no 
surprise,
because it is also the brainchild of TJ Holowaychuk)1 The approach Jade takes 
is very
minimal: what you write doesn1t resemble HTML at all, which certainly 
represents a lot
less typing: no more angle brackets or closing tags1 The Jade engine then takes 
that and
converts it to HTML1

Jade is very appealing, but that level of abstraction comes at a cost1 If 
you1re a frontend
developer, you have to understand HTML and understand it well, even if you1re 
actually
writing your views in Jade1 Most frontend developers I know are uncomfortable 
with
the idea of their primary markup language being abstracted away1 For this 
reason, I am
recommending the use of another, less abstract templating framework called 
Handle‐
bars1 Handlebars (which is based on the popular language-independent templating
language Mustache) doesn1t attempt to abstract away HTML for you: you write HTML
with special tags that allow Handlebars to inject content1

To  provide  Handlebars  support,  we1ll  use  Eric  Ferraiuolo1s  
express3-handlebars
package (despite the name, this package works fine with Express 410)1 In your 
project
directory, execute:

npm install --save express3-handlebars

Then in meadowlark1js, add the following lines after the app has been created:

var app = express();

// set up handlebars view engine

var handlebars = require('express3-handlebars')

1create({ defaultLayout:'main' });
app1engine('handlebars', handlebars1engine);
app1set('view   engine', 'handlebars');


This creates a view engine and configures Express to use it by default1 Now 
create a
directory called views that has a subdirectory called layouts1 If you1re an 
experienced
web developer, you1re probably already comfortable with the concepts of layouts 
(some‐
times called “master pages”)1 When you build a website, there1s a certain 
amount of
HTML that1s the same—or very close to the same—on every page1 Not only does it
become tedious to rewrite all that repetitive code for every page, it creates a 
potential
maintenance nightmare: if you want to change something on every page, you have 
to
change all the files1 Layouts free you from this, providing a common framework 
for all
the pages on your site1

So let1s create a template for our site1 Create a file called 
views/layouts/main1handlebars:

<!doctype html>

<html>

<head>

<title>Meadowlark Travel</title>

</head>

<body>

{{{body}}}

</body>

</html>

The only thing that you probably haven1t seen before is this: {{{body}}}1 This 
expression
will be replaced with the HTML for each view1 When we created the Handlebars in‐
stance, note we specified the default layout (defaultLayout:'main')1 That means 
that
unless you specify otherwise, this is the layout that will be used for any 
view1

Now let1s create view pages for our home page, views/home1handlebars:

<h1>Welcome to Meadowlark Travel</h1>

Then our About page, views/about1handlebars:

<h1>About Meadowlark Travel</h1>

Then our Not Found page, views/4041handlebars:

<h1>404 - Not Found</h1>

And finally our Server Error page, views/5001handlebars:

<h1>500 - Server Error</h1>

You probably want your editor to associate 1handlebars and 1hbs (an‐
other common extension for Handlebars files) with HTML, to enable
syntax highlighting and other editor features1 For vim, you can add
the   line   au  BufNewFile,BufRead  *1handlebars  set  file
type=html to  your  ~/1vimrc  file1  For  other  editors,  consult  your
documentation1


Now that we1ve got some views set up, we have to replace our old routes with 
new routes
that use these views:

app1get('/', function(req, res) {
res1render('home');

});

app1get('/about', function(req, res) {
res1render('about');

});

// 404 catch-all handler (middleware)

app1use(function(req, res, next){
res1status(404);
res1render('404');

});

// 500 error handler (middleware)

app1use(function(err, req, res, next){
console1error(err1stack);
res1status(500);
res1render('500');

});

Note that we no longer have to specify the content type or status code: the 
view engine
will return a content type of text/html and a status code of 200 by default1 In 
the catch-
all handler, which provides our custom 404 page, and the 500 handler, we have 
to set
the status code explicitly1

If you start your server and check out the home or About page, you1ll see that 
the views
have been rendered1 If you examine the source, you1ll see that the boilerplate 
HTML
from views/layouts/main1handlebars is there1

Static Files and Views

Express relies on a middleware to handle static files and views1 Middleware is 
a concept
that will be covered in more detail in Chapter 101 For now, it1s sufficient to 
know that
middleware provides modularization, making it easier to handle requests1

The static middleware allows you to designate one or more directories as 
containing
static resources that are simply to be delivered to the client without any 
special handling1
This is where you would put things like images, CSS files, and client-side 
JavaScript files1

In your project directory, create a subdirectory called public (we call it 
public because
anything in this directory will be served to the client without question)1 
Then, before
you declare any routes, you1ll add the static middleware:

app1use(express1static(  dirname + '/public'));


The static middleware has the same effect as creating a route for each static 
file you
want to deliver that renders a file and returns it to the client1 So let1s 
create an img
subdirectory inside public, and put our logo1png file in there1

Now we can simply reference /img/logo1png (note, we do not specify public; that 
di‐
rectory is invisible to the client), and the static middleware will serve that 
file, setting
the content type appropriately1 Now let1s modify our layout so that our logo 
appears on
every page:

<body>

<header><img src="/img/logo1png" alt="Meadowlark Travel Logo"></header>

{{{body}}}

</body>

The <header> element was introduced in HTML5 to provide addi‐
tional semantic information about content that appears at the top of
the page, such as logos, title text, or navigation1

Dynamic Content in Views

Views aren1t simply a complicated way to deliver static HTML (though they can 
certainly
do that as well)1 The real power of views is that they can contain dynamic 
information1

Let1s say that on the About page, we want to deliver a “virtual fortune 
cookie1” In our

meadowlark1js file, we define an array of fortune cookies:

var fortunes = [

"Conquer your fears or they will conquer you1",
"Rivers need springs1",

"Do not fear what you don't know1",
"You will have a pleasant surprise1",
"Whenever possible, keep it simple1",

];

Modify the view (/views/about1handlebars) to display a fortune:

<h1>About Meadowlark Travel</h1>

<p>Your fortune for the day:</p>

<blockquote>{{fortune}}</blockquote>

Now modify the route /about to deliver the random fortune cookie:

app1get('/about', function(req, res){

var randomFortune =

fortunes[Math1floor(Math1random() * fortunes1length)];
res1render('about', { fortune: randomFortune });

});


Now if you restart the server and load the /about page, you1ll see a random 
fortune1
Templating is incredibly useful, and we will be covering it in depth in Chapter 
71

Conclusion

We1ve created a very basic website with Express1 Even though it1s simple, it 
contains all
the seeds we need for a full-featured website1 In the next chapter, we1ll be 
crossing our
ts and dotting our is in preparation for adding more advanced functionality1


CHAPTER 4

Tidying Up

In the last two chapters, we were just experimenting: dipping our toes into the 
waters,
so to speak1 Before we proceed to more complex functionality, we1re going to do 
some
housekeeping and build some good habits into our work1

In this chapter, we1ll start our Meadowlark Travel project in earnest1 Before 
we start
building the website itself, though, we1re going to make sure we have the tools 
we need
to produce a high-quality product1

The running example in this book is not necessarily one you have to
follow1 If you1re anxious to build your own website, you could follow
the framework of the running example, but modify it accordingly so
that  by  the  time  you  finish  this  book,  you  could  have  a  finished
website!

Best Practices

The phrase “best practices” is one you hear thrown around a lot these days, and 
it means
that you should “do things right” and not cut corners (we1ll talk about what 
this means
specifically in a moment)1 No doubt you1ve heard the engineering adage that 
your op‐
tions     are “fast,” “cheap,” and “good,” and you can pick any two1 The thing 
that1s always
bothered me about this model is that it doesn1t take into account the accrual 
value of
doing things correctly1 The first time you do something correctly, it may take 
five times
as long to do it as it would have to do it quick and dirty1 The second time, 
though, it1s
only going to take three times as long1 By the time you1ve done it correctly a 
dozen times,
you1ll be doing it almost as fast as the quick and d


